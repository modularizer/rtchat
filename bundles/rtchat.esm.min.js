function e(e){return e&&"object"==typeof e&&!Array.isArray(e)}function t(n,s){const i={...n};return e(n)&&e(s)&&Object.keys(s).forEach(o=>{e(s[o])?o in n?i[o]=t(n[o],s[o]):Object.assign(i,{[o]:s[o]}):Object.assign(i,{[o]:s[o]})}),i}class n{static getDefaults(){return{name:null,userInfo:{},mqtt:{broker:"wss://broker.emqx.io:8084/mqtt",clientId:null,username:null,password:null,reconnectPeriod:500,connectTimeout:1e4},webrtc:{iceServers:[{urls:"stun:stun.l.google.com:19302"},{urls:"stun:stun1.l.google.com:19302"},{urls:"stun:stun2.l.google.com:19302"},{urls:"stun:stun3.l.google.com:19302"},{urls:"stun:stun4.l.google.com:19302"}],iceTransportPolicy:"all",bundlePolicy:"balanced",rtcpMuxPolicy:"require",waitForAnswerTimeout:1100},topic:{base:"mrtchat",room:null,separator:"/"},storage:null,crypto:null,mqttLibrary:null,compression:{enabled:!0,library:"lz-string",threshold:100},connection:{autoConnect:!0,autoReconnect:!0,maxReconnectAttempts:1/0,reconnectDelay:1e3,connectionTimeout:3e4,autoAcceptConnections:!1},history:{enabled:!0,maxLength:1e3},tabs:{enabled:!0,pollInterval:250,timeout:300},debug:!1,logger:null,load:!0}}constructor(e={}){const n=this.normalizeUserConfig(e),s={name:null,userInfo:{},mqtt:{broker:"wss://broker.emqx.io:8084/mqtt",clientId:null,username:null,password:null,reconnectPeriod:500,connectTimeout:1e4},webrtc:{iceServers:[{urls:"stun:stun.l.google.com:19302"},{urls:"stun:stun1.l.google.com:19302"},{urls:"stun:stun2.l.google.com:19302"},{urls:"stun:stun3.l.google.com:19302"},{urls:"stun:stun4.l.google.com:19302"}],iceTransportPolicy:"all",bundlePolicy:"balanced",rtcpMuxPolicy:"require",waitForAnswerTimeout:1100},topic:{base:"mrtchat",room:null,separator:"/"},storage:null,crypto:null,mqttLibrary:null,compression:{enabled:!0,library:"lz-string",threshold:100},connection:{autoConnect:!0,autoReconnect:!0,maxReconnectAttempts:1/0,reconnectDelay:1e3,connectionTimeout:3e4,autoAcceptConnections:!1},history:{enabled:!0,maxLength:1e3},tabs:{enabled:!0,pollInterval:250,timeout:300},debug:!1,logger:null,load:!0};this.config=t(s,n),this.applyComputedDefaults(),this.validate(),this.normalize()}normalizeUserConfig(e){const t={...e};return"string"==typeof e.topic&&(t.topic={room:e.topic}),t}applyComputedDefaults(){this.config.name||(this.config.name=this.getDefaultName()),this.config.topic.room||(this.config.topic.room=this.getDefaultRoom()),(null===this.config.webrtc.iceServers||Array.isArray(this.config.webrtc.iceServers)&&0===this.config.webrtc.iceServers.length)&&(this.config.webrtc.iceServers=[{urls:"stun:stun.l.google.com:19302"},{urls:"stun:stun1.l.google.com:19302"},{urls:"stun:stun2.l.google.com:19302"},{urls:"stun:stun3.l.google.com:19302"},{urls:"stun:stun4.l.google.com:19302"}])}getDefaultName(){if("undefined"!=typeof window&&window.localStorage)try{const e=localStorage.getItem("rtchat_name")||localStorage.getItem("name");if(e&&!e.startsWith("anon"))return e}catch(e){}return`User #${Math.floor(1e3*Math.random())}`}getDefaultRoom(){if("undefined"!=typeof window&&window.location){const e=window.location.hostname,t=window.location.pathname.replace(/rtchat\/?/,"").replace(/index\.html$/,"").replace(/\.html$/,"").replace(/[^a-zA-Z0-9]/g,"");return["localhost","127.0.0.1"].includes(e)?t||"default":e+t}return"default"}validate(){if(this.config.name){if(this.config.name.includes("(")||this.config.name.includes(")")||this.config.name.includes("|"))throw new Error("Name cannot contain (, ), or |");if(this.config.name!==this.config.name.trim())throw new Error("Name cannot have leading or trailing spaces")}if(this.config.mqtt.broker)try{new URL(this.config.mqtt.broker)}catch(e){throw new Error(`Invalid MQTT broker URL: ${this.config.mqtt.broker}`)}if(this.config.webrtc.iceServers&&!Array.isArray(this.config.webrtc.iceServers)&&"string"!=typeof this.config.webrtc.iceServers)throw new Error("iceServers must be an array or string")}normalize(){if(!Array.isArray(this.config.webrtc.iceServers)){const e=this.config.webrtc.iceServers;"string"==typeof e?this.config.webrtc.iceServers=[{urls:e}]:e&&e.urls?this.config.webrtc.iceServers=[e]:this.config.webrtc.iceServers=[{urls:"stun:stun.l.google.com:19302"},{urls:"stun:stun1.l.google.com:19302"},{urls:"stun:stun2.l.google.com:19302"},{urls:"stun:stun3.l.google.com:19302"},{urls:"stun:stun4.l.google.com:19302"}]}this.config.webrtc.iceServers=this.config.webrtc.iceServers.map(e=>"string"==typeof e?{urls:e}:e),this.config.topic.separator&&this.config.topic.room.includes(this.config.topic.separator)}get name(){return this.config.name}get broker(){return this.config.mqtt.broker}get iceServers(){return this.config.webrtc.iceServers}get topic(){const e=this.config.topic.separator||"/";return`${this.config.topic.base}${e}${this.config.topic.room}`}get baseTopic(){return this.config.topic.base}get room(){return this.config.topic.room}getConfig(){return this.config}update(e){const n=this.normalizeUserConfig(e);this.config=t(this.config,n),this.applyComputedDefaults(),this.validate(),this.normalize()}}const s={default:()=>new n({}),performance:()=>new n({webrtc:{iceServers:[{urls:"stun:stun.l.google.com:19302"},{urls:"stun:stun1.l.google.com:19302"},{urls:"stun:stun2.l.google.com:19302"},{urls:"stun:stun3.l.google.com:19302"},{urls:"stun:stun4.l.google.com:19302"}],iceTransportPolicy:"all"},connection:{autoReconnect:!0,reconnectDelay:500}}),privacy:e=>new n({webrtc:{iceServers:e||[{urls:"stun:stun.l.google.com:19302"}]}}),development:(e="ws://localhost:1883")=>new n({mqtt:{broker:e},debug:!0}),production:()=>new n({compression:{enabled:!0},history:{maxLength:500},connection:{autoReconnect:!0,maxReconnectAttempts:10},debug:!1})};class i{constructor(){if(this.constructor===i)throw new Error("StorageAdapter is an abstract class and cannot be instantiated directly. Extend it instead.")}getItem(e){throw new Error("getItem must be implemented by subclass")}setItem(e,t){throw new Error("setItem must be implemented by subclass")}removeItem(e){throw new Error("removeItem must be implemented by subclass")}clear(){throw new Error("clear must be implemented by subclass")}key(e){throw new Error("key must be implemented by subclass")}get length(){throw new Error("length must be implemented by subclass")}}class o extends i{constructor(){if(super(),"undefined"==typeof window||!window.localStorage)throw new Error("localStorage is not available in this environment");this.storage=window.localStorage}getItem(e){try{return this.storage.getItem(e)}catch(e){return console.warn("localStorage.getItem failed:",e),null}}setItem(e,t){try{this.storage.setItem(e,t)}catch(e){if(console.warn("localStorage.setItem failed:",e),"QuotaExceededError"===e.name)throw new Error("Storage quota exceeded")}}removeItem(e){try{this.storage.removeItem(e)}catch(e){console.warn("localStorage.removeItem failed:",e)}}clear(){try{this.storage.clear()}catch(e){console.warn("localStorage.clear failed:",e)}}key(e){try{return this.storage.key(e)}catch(e){return console.warn("localStorage.key failed:",e),null}}get length(){try{return this.storage.length}catch(e){return 0}}}class a extends i{constructor(){super(),this.data={}}getItem(e){return this.data[e]||null}setItem(e,t){this.data[e]=String(t)}removeItem(e){delete this.data[e]}clear(){this.data={}}key(e){return Object.keys(this.data)[e]||null}get length(){return Object.keys(this.data).length}}class r{constructor(){this.events={}}on(e,t){if("function"!=typeof t)throw new Error("Handler must be a function");return this.events[e]||(this.events[e]=[]),this.events[e].push(t),()=>this.off(e,t)}off(e,t){this.events[e]&&(this.events[e]=this.events[e].filter(e=>e!==t))}emit(e,...t){if(!this.events[e])return;[...this.events[e]].forEach(n=>{try{n(...t)}catch(t){console.error(`Error in event handler for ${e}:`,t)}})}once(e,t){const n=(...s)=>{t(...s),this.off(e,n)};return this.on(e,n)}removeAllListeners(e){e?delete this.events[e]:this.events={}}listenerCount(e){return this.events[e]?this.events[e].length:0}}class l{constructor(){this.promise=new Promise((e,t)=>{this.resolve=e,this.reject=t})}}class c{constructor(e,t){this.storage=e,this.config=t,this.tabID=null,this.interval=null,this.reinitializing=!1,this.instanceToken=this._generateRandomToken(),this.writeCounter=0,this.initialize()}_generateRandomToken(){return"undefined"!=typeof crypto&&"function"==typeof crypto.randomUUID?crypto.randomUUID():Math.random().toString(36).slice(2)+Date.now().toString(36)+Math.random().toString(36).slice(2)}_nextWriteToken(){return this.writeCounter+=1,`${this.instanceToken}-${this.writeCounter}-${Date.now()}`}_normalizeTabs(e){const t=[];for(let n of Array.isArray(e)?e:[]){const e=Number(n);Number.isFinite(e)&&e>=0&&t.push(Math.floor(e))}t.sort((e,t)=>e-t);const n=[];for(let e of t)0!==n.length&&n[n.length-1]===e||n.push(e);return n}_tabsChanged(e,t){if(e.length!==t.length)return!0;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!0;return!1}_readTabState(){const e=this.storage.getItem("tabs");let t=null,n=[];if(e)try{const s=JSON.parse(e);Array.isArray(s)?n=s:s&&Array.isArray(s.tabs)&&(n=s.tabs,t=s.writer||null)}catch(e){this.config.debug&&console.warn("TabManager: failed to parse tab state payload, resetting.",e),this.storage.removeItem("tabs")}const s=this._normalizeTabs(n);return s.length!==n.length&&(this.storage.setItem("tabs",JSON.stringify({writer:t,tabs:s})),this.config.debug&&n.length>s.length&&console.log(`Removed ${n.length-s.length} invalid/duplicate tab ID(s)`)),{writer:t,tabs:s}}_writeTabState(e,t){const n=this._normalizeTabs(e);return this.storage.setItem("tabs",JSON.stringify({writer:t||null,tabs:n})),n}_readAndDeduplicateTabs(){return this._readTabState().tabs}_cleanupStaleTabs(){let e=this._readAndDeduplicateTabs();const t=Date.now(),n=1e3*this.config.tabs.timeout,s=[];for(let i of e){const e=this.storage.getItem("tabpoll_"+i);if(e){const o=new Date(1*e);"Invalid Date"==o||t-o>n?this.storage.removeItem("tabpoll_"+i):s.push(i)}else this.storage.removeItem("tabpoll_"+i)}return this._tabsChanged(e,s)&&this._writeTabState(s,this._nextWriteToken()),s}initialize(){if(!this.config.tabs.enabled)return void(this.tabID=null);this._cleanupStaleTabs();const e=10;let t=0,n=null;for(;t<e&&null===n;){let s=this._readAndDeduplicateTabs(),i=0;if(s.length>0){const e=[...s].sort((e,t)=>e-t);for(let t=0;t<e.length;t++){if(e[t]!==t){i=t;break}i=t+1}}let o=this._readAndDeduplicateTabs();if(o.includes(i))t++,this.config.debug&&t<e&&console.log(`Tab ID conflict detected, retrying... (attempt ${t+1}/10)`);else{const s=[...o,i],a=this._nextWriteToken();this._writeTabState(s,a);const r=this._readTabState();r.writer===a&&r.tabs.includes(i)?n=i:(t++,this.config.debug&&t<e&&console.log(`Tab ID conflict detected after claim verification, retrying... (attempt ${t+1}/10)`))}}if(null===n)throw new Error("Failed to acquire unique tab ID after 10 attempts");this.tabID=n;const s="tabpoll_"+this.tabID;this.storage.setItem(s,Date.now().toString()),this.interval=setInterval(()=>{this._ensureTabStillRegistered(),this.storage.setItem(s,Date.now().toString())},this.config.tabs.pollInterval),this.config.debug&&console.log("Tab ID: ",this.tabID)}getTabID(){return this.tabID}cleanup(){if(this.interval&&(clearInterval(this.interval),this.interval=null),null!==this.tabID){let e=this._readAndDeduplicateTabs();const t=e.filter(e=>e!==this.tabID);this._tabsChanged(e,t)&&this._writeTabState(t,this._nextWriteToken()),this.storage.removeItem("tabpoll_"+this.tabID)}}_ensureTabStillRegistered(){if(null===this.tabID||this.reinitializing)return;this._readAndDeduplicateTabs().includes(this.tabID)||(this.config.debug&&console.warn(`Lost ownership of tab ID ${this.tabID}, attempting recovery`),this._recoverFromLostRegistration())}_recoverFromLostRegistration(){if(this.reinitializing)return;this.reinitializing=!0;const e=this.tabID;try{this.cleanup(),this.tabID=null,this.initialize(),this.config.debug&&console.log(`Recovered tab ID. Old ID: ${e}, New ID: ${this.tabID}`)}finally{this.reinitializing=!1}}}class d{constructor(e){this.config=e,this.mqtt=null,this.compression=null,this.loading=!1}async load(){if(this.loading)return this.waitForLoad();if(this.loading=!0,this.config.mqttLibrary)return this.mqtt=this.config.mqttLibrary,this.loading=!1,this.mqtt;if("undefined"!=typeof window)return window.mqtt?(this.mqtt=window.mqtt,this.loading=!1,this.mqtt):this.loadFromCDN();throw new Error("MQTT library not available and cannot be loaded")}loadFromCDN(){return new Promise((e,t)=>{const n=document.createElement("script");n.src="https://unpkg.com/mqtt/dist/mqtt.min.js",n.onload=()=>{window.mqtt?(this.mqtt=window.mqtt,this.loadCompression().then(()=>{this.loading=!1,e(this.mqtt)})):(this.loading=!1,t(new Error("MQTT library failed to load")))},n.onerror=()=>{this.loading=!1,t(new Error("Failed to load MQTT library from CDN"))},document.head.appendChild(n)})}async loadCompression(){if(!this.config.compression.enabled)return;return"lz-string"===this.config.compression.library?window.LZString?void(this.compression=window.LZString):new Promise((e,t)=>{const n=document.createElement("script");n.src="https://cdnjs.cloudflare.com/ajax/libs/lz-string/1.4.4/lz-string.min.js",n.onload=()=>{window.LZString?(this.compression=window.LZString,e()):t(new Error("LZ-String library failed to load"))},n.onerror=()=>{t(new Error("Failed to load LZ-String library"))},document.head.appendChild(n)}):void 0}getMQTT(){return this.mqtt}getCompression(){return this.compression}compress(e){if(!this.compression||!this.config.compression.enabled)return e;const t="string"==typeof e?e:JSON.stringify(e);return t.length<this.config.compression.threshold?e:this.compression.compressToUint8Array?this.compression.compressToUint8Array(t):e}decompress(e){return this.compression&&this.config.compression.enabled&&this.compression.decompressFromUint8Array?this.compression.decompressFromUint8Array(e):e}waitForLoad(){return new Promise(e=>{const t=setInterval(()=>{!this.loading&&this.mqtt&&(clearInterval(t),e(this.mqtt))},100)})}}if("undefined"!=typeof navigator&&navigator.mediaDevices&&navigator.mediaDevices.getUserMedia){const e=navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);navigator.mediaDevices.getUserMedia=function(t){return console.log("ðŸŽ¥ðŸŽ¤ getUserMedia CALLED with constraints:",t),console.trace("getUserMedia call stack"),e(t).then(e=>(console.log("ðŸŽ¥ðŸŽ¤ getUserMedia RETURNED stream with tracks:",e.getTracks().map(e=>`${e.kind}:${e.id}`).join(", ")),e.getTracks().forEach(e=>{e.addEventListener("ended",()=>{console.log("ðŸ›‘ Track ENDED:",e.kind,e.id)})}),e))}}class h extends r{constructor(e){super();const t=(e=e||{})instanceof n?e:new n(e),s=t.getConfig(),i=e.storage||new o;let a=null;s.tabs.enabled&&(a=new c(i,s));const r=new d(s),l=a?a.getTabID():null;this.name=s.name+(l?"("+l+")":""),this.userInfo=s.userInfo||{},this.mqttBroker=s.mqtt.broker,this.iceServers=s.webrtc.iceServers,this.baseTopic=s.topic.base,this.topic=t.topic,this.config=t,this.storage=i,this.tabManager=a,this.mqttLoader=r,this.maxHistoryLength=s.history.maxLength,s.name.startsWith("anon")||s.name.startsWith("User #")||(i.setItem("name",s.name),i.setItem("rtchat_name",s.name));const h=!1!==e.load;this.load=this.load.bind(this),this._onMQTTConnect=this._onMQTTConnect.bind(this),this.onConnectedToMQTT=this.onConnectedToMQTT.bind(this),this._onMQTTMessage=this._onMQTTMessage.bind(this),this.onMQTTMessage=this.onMQTTMessage.bind(this),this.beforeunload=this.beforeunload.bind(this),this.postPubliclyToMQTTServer=this.postPubliclyToMQTTServer.bind(this);for(let[e,t]of Object.entries(this.mqttHandlers))this.mqttHandlers[e]=t.bind(this);this.changeName=this.changeName.bind(this),this.recordNameChange=this.recordNameChange.bind(this),this.onNameChange=this.onNameChange.bind(this),this.shouldConnectToUser=this.shouldConnectToUser.bind(this),this.connectToUser=this.connectToUser.bind(this),this.connectionToUser=this.connectionToUser.bind(this),this.connectionsToUsers=this.connectionsToUsers.bind(this),this.disconnectFromUser=this.disconnectFromUser.bind(this),this.onConnectedToUser=this.onConnectedToUser.bind(this),this.onDisconnectedFromUser=this.onDisconnectedFromUser.bind(this),this.onrtcdisconnectedFromUser=this.onrtcdisconnectedFromUser.bind(this),this.callUser=this.callUser.bind(this),this.callFromUser=this.callFromUser.bind(this),this.acceptCallFromUser=this.acceptCallFromUser.bind(this),this.oncallconnected=this.oncallconnected.bind(this),this.isConnectedToUser=this.isConnectedToUser.bind(this),this.sendOverRTC=this.sendOverRTC.bind(this),this.onrtcmessage=this.onrtcmessage.bind(this),this.onrtcerror=this.onrtcerror.bind(this),this.rtcConnections={},this.knownUsers={},this.pendingIceCandidates={},this.maxConnectRetries=s.webrtc?.maxConnectRetries||3,this.connectRetryDelay=s.webrtc?.connectRetryDelay||4e3,this.waitForAnswerTimeout=s.webrtc?.waitForAnswerTimeout||12e3,this.connectingUsers=new Set,this.attemptedPeers=new Set,this.waitingForPeerInitiation=new Map,this.sharedLocalStream=null,this.maxConnectRetries=s.webrtc?.maxConnectRetries||3,this.connectRetryDelay=s.webrtc?.connectRetryDelay||4e3,this.mqttHistory=[],this.announceInterval=null,h&&this.load();if(!1!==e.assignToWindow&&"undefined"!=typeof window)if(window.rtc){let e=window.rtc;console.warn("RTC already exists. Saving old RTC object to window.rtc.old,",e),e.name,window.rtc={oldName:e,name:this}}else window.rtc=this}async load(){await this.mqttLoader.load();const e=this.mqttLoader.getMQTT();if(!e)throw new Error("MQTT library not available");const t=this.config.getConfig(),n={clientId:t.mqtt?.clientId||this.baseTopic+this.name,username:t.mqtt.username,password:t.mqtt.password,reconnectPeriod:t.mqtt.reconnectPeriod,connectTimeout:t.mqtt.connectTimeout};this.client=e.connect(this.mqttBroker,n),this.client.on("connect",this._onMQTTConnect.bind(this)),this.client.on("message",this._onMQTTMessage.bind(this)),"undefined"!=typeof window&&window.addEventListener("beforeunload",this.beforeunload.bind(this))}_onMQTTConnect(){console.log(`MQTT transport connected, subscribing to ${this.topic} as ${this.name}`),this.client.subscribe(this.topic,(e=>{if(e)console.error("Error subscribing to "+this.topic,e);else{console.log("subscribed to ",this.topic),console.log(`MQTT subscribed to ${this.topic}, listening for presence as ${this.name}`),setTimeout(()=>{console.log(`MQTT connect: announcing presence as ${this.name} in ${this.topic}`),this.postPubliclyToMQTTServer("connect",this.userInfo),this.onConnectedToMQTT()},500);let e=0;this.announceInterval=setInterval(()=>{Object.keys(this.rtcConnections).some(e=>{const t=this.rtcConnections[e];return t&&t.peerConnection&&("connected"===t.peerConnection.connectionState||"completed"===t.peerConnection.connectionState)})||this.postPubliclyToMQTTServer("connect",this.userInfo),e++,e>=5&&this.announceInterval&&(clearInterval(this.announceInterval),this.announceInterval=setInterval(()=>{Object.keys(this.rtcConnections).some(e=>{const t=this.rtcConnections[e];return t&&t.peerConnection&&("connected"===t.peerConnection.connectionState||"completed"===t.peerConnection.connectionState)})||this.postPubliclyToMQTTServer("connect",this.userInfo)},3e4))},3e3)}}).bind(this))}onConnectedToMQTT(){console.log("Connected to MQTT: "+this.topic+" as "+this.name),this.emit("mqttconnected",this.topic,this.name)}_onMQTTMessage(e,t){if(e===this.topic){let e,n;if(null==t)return void console.error("Received null or undefined MQTT message data");try{const s=this.mqttLoader.decompress(t);if(null==s)return void console.error("Decompression returned null/undefined for data:",t);if("string"==typeof s?n=s:s instanceof Uint8Array?n=(new TextDecoder).decode(s):"object"==typeof s?e=s:n=String(s),!e&&n)try{e=JSON.parse(n)}catch(e){return void console.error("Failed to parse JSON from decompressed string:",e,"String:",n)}}catch(s){console.warn("Decompression failed, attempting fallback parsing:",s.message);try{if(n=t instanceof Uint8Array?(new TextDecoder).decode(t):"string"!=typeof t?String(t):t,!n)return void console.error("Converted payload string is empty");e=JSON.parse(n)}catch(e){return void console.error("Failed to parse MQTT message:",e,"Raw data:",t,"String:",n)}}if(!e||"object"!=typeof e)return void console.error("Invalid payload: not an object","Payload:",e,"Type:",typeof e,"Original data:",t);if(!e.sender)return void console.error("Invalid payload: missing sender property","Payload:",e,"Keys:",Object.keys(e));if(e.sender===this.name)return;let s=e.subtopic;for(e.sent=!1,e.receiveTimestamp=Date.now(),this.mqttHistory.push(e);this.mqttHistory.length>this.maxHistoryLength;)this.mqttHistory.shift();this.mqttHandlers[s]?this.mqttHandlers[s](e):(this.onMQTTMessage(s,e.data,e.sender,e.timestamp),console.warn("Unhandled message: "+s,e))}}onMQTTMessage(e,t,n,s){console.log("Received message from "+n+" on "+e,t),this.emit("mqttmessage",e,t,n,s)}beforeunload(){this.postPubliclyToMQTTServer("unload","disconnecting"),this.tabManager&&this.tabManager.cleanup()}disconnect(){for(let e of Object.keys(this.rtcConnections))this.disconnectFromUser(e);this.announceInterval&&(clearInterval(this.announceInterval),this.announceInterval=null),this.connectionMaintenanceInterval&&(clearInterval(this.connectionMaintenanceInterval),this.connectionMaintenanceInterval=null),this.client&&(this.client.end(),this.client=null),this.tabManager&&this.tabManager.cleanup()}postPubliclyToMQTTServer(e,t){let n={sender:this.name,timestamp:Date.now(),subtopic:e,data:t},s=JSON.stringify(n);if(s.length,this.mqttLoader){const e=this.mqttLoader.compress(s);e!==s&&(s=e)}for("RTCIceCandidate"===e?t&&null!==t||console.log("Sending message to "+this.topic+" subtopic "+e+" (end of ICE gathering)"):console.log("Sending message to "+this.topic+" subtopic "+e,t),this.client.publish(this.topic,s),n.sent=!0,this.mqttHistory.push(n);this.mqttHistory.length>this.maxHistoryLength;)this.mqttHistory.shift()}mqttHandlers={connect:e=>{console.log(`MQTT connect message received from ${e.sender}, initiating WebRTC signaling flow`);const t=this.rtcConnections[e.sender];if(t){const n=t.peerConnection.connectionState,s=t.peerConnection.iceConnectionState;if("connected"===n&&("connected"===s||"completed"===s))return void(this.knownUsers[e.sender]=e.data);const i=this._shouldInitiateConnection(e.sender);if(!i||"failed"!==n&&"closed"!==n&&"failed"!==s&&"closed"!==s)if("new"===n){const n=Date.now()-(t.createdAt||0);if(!(i&&n>1e4))return void(this.knownUsers[e.sender]=e.data);console.warn("Connection to "+e.sender+" stuck in 'new' state for "+n+"ms, allowing retry"),this.disconnectFromUser(e.sender)}else{if("connecting"===n)return void(this.knownUsers[e.sender]=e.data);{const s=Date.now()-(t.createdAt||0);if(!(i&&s>15e3))return void(this.knownUsers[e.sender]=e.data);console.warn("Connection to "+e.sender+" stuck in '"+n+"' state for "+s+"ms, allowing retry"),this.disconnectFromUser(e.sender)}}else console.warn("Connection to "+e.sender+" is broken, disconnecting"),this.disconnectFromUser(e.sender)}this.knownUsers[e.sender]=e.data,this.shouldConnectToUser(e.sender,e.data).then(t=>{if(!t)return;if(!this._shouldInitiateConnection(e.sender)){if(console.log("connect: Waiting for peer "+e.sender+" to initiate connection"),!this.waitingForPeerInitiation.has(e.sender)&&!this.connectionToUser(e.sender)&&!this.attemptedPeers.has(e.sender)){const t=setTimeout(()=>{console.warn("connect: Peer "+e.sender+" did not initiate connection within timeout. Initiating fallback connection."),this.waitingForPeerInitiation.delete(e.sender),this.connectionToUser(e.sender)||this.attemptedPeers.has(e.sender)||(this.attemptedPeers.add(e.sender),setTimeout(()=>this.attemptedPeers.delete(e.sender),this.waitForAnswerTimeout),this.connectToUser(e.sender))},this.waitForAnswerTimeout);this.waitingForPeerInitiation.set(e.sender,t)}return}const n=this.waitingForPeerInitiation.get(e.sender);n&&(clearTimeout(n),this.waitingForPeerInitiation.delete(e.sender)),this.connectionToUser(e.sender)?console.log("connect: Already connected or connecting to "+e.sender):this.attemptedPeers.has(e.sender)?console.log("connect: Already attempted connection to "+e.sender):(this.attemptedPeers.add(e.sender),setTimeout(()=>this.attemptedPeers.delete(e.sender),this.waitForAnswerTimeout),this.connectToUser(e.sender))})},nameChange:e=>{this.recordNameChange(e.data.oldName,e.data.newName)},unload:e=>{this.disconnectFromUser(e.sender),delete this.knownUsers[e.sender]},RTCOffer:e=>{this.shouldConnectToUser(e.sender,e.data.userInfo).then(t=>{if(t){if(e.data.offer.target!=this.name)return;const t=this.waitingForPeerInitiation.get(e.sender);t&&(clearTimeout(t),this.waitingForPeerInitiation.delete(e.sender),console.log("RTCOffer: Cleared waiting timeout for "+e.sender)),this.rtcConnections[e.sender]&&(console.warn("Already have a connection to "+e.sender+". Closing and reopening."),this.rtcConnections[e.sender].close()),this.rtcConnections[e.sender]=new u(this,e.sender),this.rtcConnections[e.sender].respondToOffer(e.data.offer.localDescription);let n=this.pendingIceCandidates[e.sender];n&&(console.log("Found pending ice candidate for "+e.sender),this.rtcConnections[e.sender].onReceivedIceCandidate(n),delete this.pendingIceCandidates[e.sender])}else console.warn("Not connecting to "+e.sender)})},RTCIceCandidate:e=>{if(e.data){let t=this.rtcConnections[e.sender];t?t.onReceivedIceCandidate(e.data):this.pendingIceCandidates[e.sender]=e.data}},RTCAnswer:e=>{if(e.data.target!=this.name)return;let t=this.rtcConnections[e.sender];t?t.receiveAnswer(e.data.localDescription):console.error("No connection found for "+e.sender)}};shouldConnectToUser(e,t){return Promise.resolve(!0)}callUser(e,t){let n;if(t instanceof MediaStream){let s=t;this.sharedLocalStream||(console.log("MQTTRTCClient.callUser: Storing provided stream as sharedLocalStream"),this.sharedLocalStream=s),console.log("MQTTRTCClient.callUser: Using provided MediaStream"),n=this.rtcConnections[e].startCall(s)}else if(t=t||{video:!0,audio:!0},this.sharedLocalStreamPromise)console.log("MQTTRTCClient.callUser: â³ Waiting for pending shared stream creation"),n=this.sharedLocalStreamPromise.then(t=>(console.log("MQTTRTCClient.callUser: â™»ï¸ Using stream from pending promise (tracks:",t.getTracks().map(e=>`${e.kind}:${e.id.substring(0,8)}`).join(", "),")"),this.rtcConnections[e].startCall(t)));else if(this.sharedLocalStream){const s=this.sharedLocalStream.getVideoTracks().length>0,i=this.sharedLocalStream.getAudioTracks().length>0;!(t.video!==s&&t.video||t.audio!==i&&t.audio)?(console.log("MQTTRTCClient.callUser: â™»ï¸ Reusing shared local stream (tracks:",this.sharedLocalStream.getTracks().map(e=>`${e.kind}:${e.id.substring(0,8)}`).join(", "),")"),n=this.rtcConnections[e].startCall(this.sharedLocalStream)):(console.log("MQTTRTCClient.callUser: âš ï¸ Shared stream doesn't match callInfo, creating new stream"),this.sharedLocalStreamPromise=navigator.mediaDevices.getUserMedia(t).then(e=>(console.log("MQTTRTCClient.callUser: ðŸ†• Created new stream (tracks:",e.getTracks().map(e=>`${e.kind}:${e.id.substring(0,8)}`).join(", "),")"),this.sharedLocalStream=e,this.sharedLocalStreamPromise=null,e)),n=this.sharedLocalStreamPromise.then(t=>this.rtcConnections[e].startCall(t)))}else console.log("MQTTRTCClient.callUser: ðŸ†• Creating first shared local stream"),this.sharedLocalStreamPromise=navigator.mediaDevices.getUserMedia(t).then(e=>(console.log("MQTTRTCClient.callUser: ðŸ†• Created first stream (tracks:",e.getTracks().map(e=>`${e.kind}:${e.id.substring(0,8)}`).join(", "),")"),this.sharedLocalStream=e,this.sharedLocalStreamPromise=null,e)),n=this.sharedLocalStreamPromise.then(t=>this.rtcConnections[e].startCall(t));return{start:n,end:this.rtcConnections[e].callEndPromise.promise}}endCallWithUser(e){if(console.log("MQTTRTCClient.endCallWithUser: Ending call with "+e),console.log("MQTTRTCClient.endCallWithUser: Available connections:",Object.keys(this.rtcConnections)),this.rtcConnections[e])try{console.log("MQTTRTCClient.endCallWithUser: Calling endCall on RTCConnection for "+e),this.rtcConnections[e].endCall(),console.log("MQTTRTCClient.endCallWithUser: Sent endcall message to "+e+" via RTC data channel")}catch(t){console.warn("MQTTRTCClient.endCallWithUser: Failed to send endcall via RTC channel, trying MQTT fallback:",t);try{this.sendOverRTC("endcall",null,e),console.log("MQTTRTCClient.endCallWithUser: Sent endcall message to "+e+" via MQTT fallback")}catch(t){console.error("MQTTRTCClient.endCallWithUser: Failed to send endcall message to "+e+" via both RTC and MQTT:",t)}}else console.warn("MQTTRTCClient.endCallWithUser: No RTC connection found for "+e+", cannot send endcall message")}callFromUser(e,t,n,s){if(t=t||{video:!0,audio:!0},n){if(this.sharedLocalStreamPromise)return console.log("MQTTRTCClient.callFromUser: â³ Waiting for pending shared stream creation"),this.sharedLocalStreamPromise;if(this.sharedLocalStream){const e=this.sharedLocalStream.getVideoTracks().length>0,n=this.sharedLocalStream.getAudioTracks().length>0;if(!(t.video!==e&&t.video||t.audio!==n&&t.audio))return console.log("MQTTRTCClient.callFromUser: â™»ï¸ Reusing shared local stream (tracks:",this.sharedLocalStream.getTracks().map(e=>`${e.kind}:${e.id.substring(0,8)}`).join(", "),")"),Promise.resolve(this.sharedLocalStream)}return console.log("MQTTRTCClient.callFromUser: ðŸ†• Creating new shared local stream"),this.sharedLocalStreamPromise=navigator.mediaDevices.getUserMedia(t).then(e=>(console.log("MQTTRTCClient.callFromUser: ðŸ†• Created stream (tracks:",e.getTracks().map(e=>`${e.kind}:${e.id.substring(0,8)}`).join(", "),")"),this.sharedLocalStream=e,this.sharedLocalStreamPromise=null,e)),this.sharedLocalStreamPromise}return this.acceptCallFromUser(e,t,s).then(e=>{if(!1===e||null==e)return Promise.reject("Call rejected");const n="object"!=typeof e||null===e||void 0===e.video&&void 0===e.audio?t:e;if(this.sharedLocalStreamPromise)return console.log("MQTTRTCClient.callFromUser: â³ Waiting for pending shared stream creation (incoming)"),this.sharedLocalStreamPromise;if(this.sharedLocalStream){const e=this.sharedLocalStream.getVideoTracks().length>0,t=this.sharedLocalStream.getAudioTracks().length>0;if(!(n.video!==e&&n.video||n.audio!==t&&n.audio))return console.log("MQTTRTCClient.callFromUser: â™»ï¸ Reusing shared local stream (incoming) (tracks:",this.sharedLocalStream.getTracks().map(e=>`${e.kind}:${e.id.substring(0,8)}`).join(", "),")"),Promise.resolve(this.sharedLocalStream)}return console.log("MQTTRTCClient.callFromUser: ðŸ†• Creating new shared local stream (incoming)"),this.sharedLocalStreamPromise=navigator.mediaDevices.getUserMedia(n).then(e=>(console.log("MQTTRTCClient.callFromUser: ðŸ†• Created stream (incoming) (tracks:",e.getTracks().map(e=>`${e.kind}:${e.id.substring(0,8)}`).join(", "),")"),this.sharedLocalStream=e,this.sharedLocalStreamPromise=null,e)),this.sharedLocalStreamPromise})}oncallended(e){console.log("BaseMQTTRTCClient.oncallended: Call ended with "+e),this.emit("callended",e),console.log("BaseMQTTRTCClient.oncallended: Emitted 'callended' event for "+e)}acceptCallFromUser(e,t,n){return Promise.resolve(!0)}connectToUser(e){if(!e||e===this.name)return null;const t=this.connectionToUser(e);if(t)return console.log("connectToUser: Already connected or connecting to "+e),t;if(this.rtcConnections[e])return console.log("connectToUser: Connection to "+e+" is still negotiating"),this.rtcConnections[e];console.log(`connectToUser: Starting WebRTC offer to ${e}`);const n=new u(this,e);return this.rtcConnections[e]=n,n.sendOffer(),n}_shouldInitiateConnection(e){return!!e&&(this.name===e?this.name.length<=e.length:this.name.localeCompare(e)<0)}connectionToUser(e){let t=this.rtcConnections[e];return t&&"connected"===t.peerConnection.connectionState?t:t?(console.warn("Already have a connection to "+e+" but it's not connected.",t.peerConnection.connectionState),"failed"==t.peerConnection.connectionState?(console.warn("Connection failed. Closing and reopening."),this.disconnectFromUser(e),null):t):null}connectionsToUsers(e){return"string"==typeof(e=e||Object.keys(this.rtcConnections))&&(e=[e]),e.filter(e=>this.connectionToUser(e))}get connectedUsers(){return this.connectionsToUsers()}disconnectFromUser(e){console.warn("Closing connection to "+e);let t=this.rtcConnections[e];t?(t.close(),delete this.rtcConnections[e],console.warn("Closed connection to "+e)):console.warn("No connection to close to "+e),this.connectingUsers.delete(e),this.attemptedPeers.delete(e);const n=this.waitingForPeerInitiation.get(e);n&&(clearTimeout(n),this.waitingForPeerInitiation.delete(e))}onConnectedToUser(e){console.log("Connected to user ",e),this.emit("connectedtopeer",e)}isConnectedToUser(e){return this.rtcConnections[e]&&"connected"===this.rtcConnections[e].peerConnection.connectionState}onrtcdisconnectedFromUser(e){this.rtcConnections[e]?(console.log("Disconnected from user ",e),delete this.rtcConnections[e],this.onDisconnectedFromUser(e)):console.warn("Already disconnected from"+e)}onDisconnectedFromUser(e){console.log("Disconnected from user ",e),this.emit("disconnectedfrompeer",e),this.connectingUsers.delete(e),this.attemptedPeers.delete(e)}changeName(e){let t=this.name;const n=this.tabManager?this.tabManager.getTabID():null;this.name=e+(n?"("+n+")":""),this.storage?(this.storage.setItem("name",e),this.storage.setItem("rtchat_name",e)):"undefined"!=typeof localStorage&&localStorage.setItem("name",e),this.postPubliclyToMQTTServer("nameChange",{oldName:t,newName:this.name})}recordNameChange(e,t){this.knownUsers[t]=this.knownUsers[e],delete this.knownUsers[e],this.rtcConnections[t]=this.rtcConnections[e],delete this.rtcConnections[e],this.onNameChange(e,t)}onNameChange(e,t){console.log(e+" changed name to "+t)}sendOverRTC(e,t,n){if(!e)throw new Error("No channel specified");if(!this.rtcHandlers[e])throw new Error("Unsupported RTC channel: "+e);let s=this.rtcHandlers[e],i=t=t||e;s&&!s.raw&&(i=(s.serializer||JSON.stringify)(t));for(let s of this.connectionsToUsers(n))if(this.verifyUser(e,t,s)){const t=this.rtcConnections[s].send(e,i);t&&"function"==typeof t.then&&t.catch(t=>{console.error(`Failed to send on channel ${e} to ${s}:`,t)})}else console.warn("Not connected to "+s)}verifyUser(e,t,n){return!0}rtcHandlers={connectedViaRTC:(e,t)=>{this.onConnectedToUser(t)}};onrtcmessage(e,t,n){let s=this.rtcHandlers[e],i=t;s&&!s.raw&&(i=(s.deserializer||JSON.parse)(t)),s?s(i,n):console.warn("No handler found for "+e),this.emit("rtcmessage",e,i,n)}onrtcerror(e,t,n){let s=this.rtcHandlers[e];s&&s.error&&s.error(t,n)}}class u{constructor(e,t){const n=e.iceServers||(e.stunServer?[{urls:e.stunServer}]:[{urls:"stun:stun4.l.google.com:19302"}]);this.rtcConfiguration={iceServers:n,iceTransportPolicy:e.config?.getConfig()?.webrtc?.iceTransportPolicy||"all",bundlePolicy:e.config?.getConfig()?.webrtc?.bundlePolicy||"balanced",rtcpMuxPolicy:e.config?.getConfig()?.webrtc?.rtcpMuxPolicy||"require"},this.target=t,this.mqttClient=e,this.dataChannels={},this.createdAt=Date.now(),this.pendingIceCandidates=[],this.peerConnection=new RTCPeerConnection(this.rtcConfiguration),this.peerConnection.onicecandidate=this.onicecandidate.bind(this),this.startCall=this.startCall.bind(this),this.onTrack=this.onTrack.bind(this),this.sentOffer=!1,this.streamChannels=["streamice","streamoffer","streamanswer","endcall"],this.dataChannelDeferredPromises=Object.fromEntries(Object.entries(e.rtcHandlers).map(([e,t])=>[e,new l])),this.streamChannels.forEach(e=>this.dataChannelDeferredPromises[e]=new l),this.loadPromise=Promise.all(Object.values(this.dataChannelDeferredPromises).map(e=>e.promise)),this.loaded=!1,this.loadPromise.then((()=>{this.loaded=!0}).bind(this)),this.peerConnection.ondatachannel=(e=>{this.registerDataChannel(e.channel)}).bind(this),this.peerConnection.oniceconnectionstatechange=function(){"disconnected"!==this.peerConnection.iceConnectionState&&"failed"!==this.peerConnection.iceConnectionState&&"closed"!==this.peerConnection.iceConnectionState||this.mqttClient.onDisconnectedFromUser(this.target)}.bind(this),this.pendingStreamIceCandidate=null,this.pendingStreamIceCandidates=[],this.streamConnection=null,this.remoteStream=null,this.localStream=null,this.sendstreamice=!1,this.initiatedCall=!1,this.streamConnectionPromise=new l,this.streamPromise=new l,this.callEndPromise=new l,this.callPromises={start:this.streamPromise.promise,end:this.callEndPromise.promise}}registerDataChannel(e){e.onmessage=(t=>{console.log("RTCConnection.registerDataChannel: Received message on channel '"+e.label+"' from "+this.target,t.data),this.onmessage(t,e.label)}).bind(this),e.onerror=(t=>{this.dataChannelDeferredPromises[e.label].reject(t),this.ondatachannelerror(t,e.label)}).bind(this),e.onopen=(t=>{console.log("RTCConnection.registerDataChannel: Data channel '"+e.label+"' opened for "+this.target),this.dataChannelDeferredPromises[e.label].resolve(t)}).bind(this),this.dataChannels[e.label]=e}setupDataChannels(){for(let[e,t]of Object.entries(this.mqttClient.rtcHandlers)){let t=this.peerConnection.createDataChannel(e);this.registerDataChannel(t)}this.streamChannels.forEach(e=>{let t=this.peerConnection.createDataChannel(e);this.registerDataChannel(t)})}startCall(e){if(this.initiatedCall=!0,this.streamConnection&&"closed"!==this.streamConnection.signalingState)return console.warn("startCall: stream connection already active or negotiating; returning existing promise"),this.streamPromise.promise;let t={video:e.getVideoTracks().length>0,audio:e.getAudioTracks().length>0};return this.streamConnection=this._makeStreamConnection(e),this.streamConnection.createOffer().then(e=>this.streamConnection.setLocalDescription(e)).then(()=>{this.send("streamoffer",JSON.stringify({offer:this.streamConnection.localDescription,streamInfo:t}))}),this.callPromises={start:this.streamPromise.promise,end:this.callEndPromise.promise},this.streamPromise.promise}_makeStreamConnection(e){return this.streamConnection?(console.warn("Already have a stream connection, reusing existing instance"),this.streamConnection):(this.localStream=e,this.streamConnection=new RTCPeerConnection(this.rtcConfiguration),e.getTracks().forEach(t=>this.streamConnection.addTrack(t,e)),this.streamConnection.onicecandidate=this.onstreamicecandidate.bind(this),this.streamConnection.ontrack=this.onTrack,this.streamConnectionPromise.resolve(this.streamConnection),this.callPromises={start:this.streamPromise.promise,end:this.callEndPromise.promise},this.streamConnection)}onTrack(e){console.warn("Track event",e),this.remoteStream=e.streams[0];let t={localStream:this.localStream,remoteStream:this.remoteStream};this.streamPromise.resolve(t),this.mqttClient.oncallconnected(this.target,t)}sendOffer(){this.peerConnection?"stable"===this.peerConnection.signalingState?(this.setupDataChannels(),this.peerConnection.createOffer().then(e=>this.peerConnection.setLocalDescription(e)).then(()=>{console.log("Sending offer to "+this.target),this.mqttClient.postPubliclyToMQTTServer("RTCOffer",{userInfo:this.mqttClient.userInfo,offer:{localDescription:this.peerConnection.localDescription,target:this.target}})}),this.sentOffer=!0):console.warn(`sendOffer: signaling state is ${this.peerConnection.signalingState}, waiting for stable state before creating offer`):console.error("sendOffer called but peerConnection missing")}respondToOffer(e){this.peerConnection.setRemoteDescription(new RTCSessionDescription(e)).then(()=>this.peerConnection.createAnswer()).then(e=>this.peerConnection.setLocalDescription(e)).then(e=>{this.mqttClient.postPubliclyToMQTTServer("RTCAnswer",{localDescription:this.peerConnection.localDescription,target:this.target})})}receiveAnswer(e){"have-local-offer"===this.peerConnection.signalingState?(this.peerConnection.setRemoteDescription(new RTCSessionDescription(e)).then(()=>{this.pendingIceCandidates&&this.pendingIceCandidates.length>0&&(console.log(`Applying ${this.pendingIceCandidates.length} pending ICE candidates for ${this.target}`),this.pendingIceCandidates.forEach(e=>{this.peerConnection.addIceCandidate(new RTCIceCandidate(e)).catch(e=>{console.warn("Error adding pending ICE candidate:",e)})}),this.pendingIceCandidates=[])}).catch(e=>{console.error("Error setting remote description:",e)}),this.loadPromise.then((()=>{this.send("connectedViaRTC",null),this.mqttClient.onConnectedToUser(this.target)}).bind(this))):"stable"!==this.peerConnection.signalingState&&console.warn("Received answer in unexpected signaling state: "+this.peerConnection.signalingState)}send(e,t){let n=this.dataChannels[e];if(!n)throw this.mqttClient.rtcHandlers[e]&&console.warn("handler found for ",e,"but no data channel"),new Error("No data channel for "+e);if("open"!==n.readyState){if("closed"===n.readyState)throw new Error("Channel closed: "+e);return new Promise((s,i)=>{const o=setTimeout(()=>{i(new Error(`Channel ${e} did not open within 10 seconds`))},1e4),a=()=>{clearTimeout(o),n.removeEventListener("open",a),n.removeEventListener("error",r);try{n.send(t),s()}catch(e){i(e)}},r=t=>{clearTimeout(o),n.removeEventListener("open",a),n.removeEventListener("error",r),i(new Error(`Channel ${e} error: ${t.message||t}`))};n.addEventListener("open",a),n.addEventListener("error",r)})}n.send(t)}onmessage(e,t){if("streamoffer"===t){console.log("received stream offer",e.data);let{offer:t,streamInfo:n}=JSON.parse(e.data);const s=n||{video:!0,audio:!0};this.mqttClient.callFromUser(this.target,s,this.initiatedCall,this.callPromises).then(e=>(this.streamConnection||(this.streamConnection=this._makeStreamConnection(e)),this.streamConnection)).catch(e=>(("Call rejected"===e||"string"==typeof e&&e.includes("rejected"))&&(console.log(`Call rejected by ${this.target}, ending call`),this.endCall()),this.streamConnectionPromise.reject(e),this.streamPromise.reject(e),null)).then(e=>{e&&e.setRemoteDescription(new RTCSessionDescription(t)).then(()=>this.streamConnection.createAnswer()).then(e=>this.streamConnection.setLocalDescription(e)).then(()=>{console.log("Sending stream answer",this.streamConnection.localDescription),this.send("streamanswer",JSON.stringify({answer:this.streamConnection.localDescription})),(this.pendingStreamIceCandidate||this.pendingStreamIceCandidates&&this.pendingStreamIceCandidates.length>0)&&console.log("Found pending stream ice candidates, will apply when remote description is set")}).catch(e=>{console.error("Error setting remote description or creating answer:",e)})})}else if("streamanswer"===t){console.log("received stream answer",e.data);let{answer:t}=JSON.parse(e.data);this.streamConnection.setRemoteDescription(new RTCSessionDescription(t)).then(()=>{if(this.pendingStreamIceCandidates&&this.pendingStreamIceCandidates.length>0&&(console.log(`Applying ${this.pendingStreamIceCandidates.length} pending ICE candidates`),this.pendingStreamIceCandidates.forEach(e=>{try{this.streamConnection.addIceCandidate(new RTCIceCandidate(e)).catch(e=>{console.warn("Error adding pending ICE candidate:",e)})}catch(e){console.warn("Error creating ICE candidate:",e)}}),this.pendingStreamIceCandidates=[]),this.pendingStreamIceCandidate)try{this.streamConnection.addIceCandidate(new RTCIceCandidate(this.pendingStreamIceCandidate)).catch(e=>{console.warn("Error adding pending ICE candidate:",e)}),this.pendingStreamIceCandidate=null}catch(e){console.warn("Error creating ICE candidate:",e)}}).catch(e=>{console.error("Error setting remote description:",e)})}else if("streamice"===t){if(console.log("received stream ice",e.data),e.data){const t=JSON.parse(e.data);this.streamConnection?this.streamConnection.remoteDescription?this.streamConnection.addIceCandidate(new RTCIceCandidate(t)).catch(e=>{console.warn("Error adding ICE candidate, storing as pending:",e),this.pendingStreamIceCandidates||(this.pendingStreamIceCandidates=[]),this.pendingStreamIceCandidates.push(t)}):(console.log("Remote description not set yet, storing ICE candidate as pending"),this.pendingStreamIceCandidates||(this.pendingStreamIceCandidates=[]),this.pendingStreamIceCandidates.push(t),this.pendingStreamIceCandidate=t):(this.pendingStreamIceCandidate=t,this.pendingStreamIceCandidates||(this.pendingStreamIceCandidates=[]),this.pendingStreamIceCandidates.push(t))}}else"endcall"===t?(console.log("RTCConnection.onmessage: Received endcall message from "+this.target),this._closeCall()):this.mqttClient.onrtcmessage(t,e.data,this.target)}endCall(){console.log("RTCConnection.endCall: Sending endcall message to "+this.target);try{const e=this.send("endcall",null);e&&"function"==typeof e.then?e.then(()=>{console.log("RTCConnection.endCall: Successfully sent endcall message to "+this.target)}).catch(e=>{console.error("RTCConnection.endCall: Failed to send endcall message (async):",e)}):console.log("RTCConnection.endCall: Successfully sent endcall message to "+this.target)}catch(e){console.error("RTCConnection.endCall: Failed to send endcall message (sync):",e)}this._closeCall()}_closeCall(){console.log("RTCConnection._closeCall: Closing call with "+this.target);const e=!!this.streamConnection;if(this.streamConnection){if(this.streamConnection.close(),this.streamConnection=null,this.remoteStream){const e=this.remoteStream.getTracks();console.log(`RTCConnection._closeCall: Stopping ${e.length} remote track(s) for ${this.target}`),e.forEach(e=>e.stop())}this.remoteStream=null,this.localStream=null}else console.log(`RTCConnection._closeCall: No streamConnection for ${this.target}`);if(e){let e=0;const t=[];if(this.mqttClient&&this.mqttClient.rtcConnections)for(const[n,s]of Object.entries(this.mqttClient.rtcConnections)){const i=!(!s||!s.streamConnection);t.push(`${n}:${i?"active":"inactive"}`),n!==this.target&&s&&s.streamConnection&&(e++,console.log(`RTCConnection._closeCall: Found other active connection: ${n}`))}if(console.log(`RTCConnection._closeCall: All connections: [${t.join(", ")}]`),console.log(`RTCConnection._closeCall: ${e} other active connections remain (excluding ${this.target})`),0===e)if(this.mqttClient&&this.mqttClient.sharedLocalStream){console.log("RTCConnection._closeCall: âœ… Last connection closed, stopping shared stream tracks");const e=this.mqttClient.sharedLocalStream.getTracks();console.log(`RTCConnection._closeCall: Shared stream has ${e.length} tracks`),e.forEach(e=>{console.log(`RTCConnection._closeCall: ðŸ›‘ Stopping ${e.kind} track ${e.id} (readyState: ${e.readyState})`),e.stop(),console.log(`RTCConnection._closeCall: âœ… Stopped ${e.kind} track ${e.id} (new readyState: ${e.readyState})`)}),this.mqttClient.sharedLocalStream=null,this.mqttClient.sharedLocalStreamPromise=null,console.log("RTCConnection._closeCall: âœ… Shared stream and promise cleared")}else console.log("RTCConnection._closeCall: No shared stream to stop");else console.log(`RTCConnection._closeCall: â¸ï¸  ${e} other connections still active, keeping shared stream alive`)}this.callEndPromise.resolve(),this.callEndPromise=new l,this.callRinging=!1,this.initiatedCall=!1,this.pendingStreamIceCandidate=null,this.streamConnectionPromise=new l,this.streamPromise=new l,this.callEndPromise=new l,this.callPromises={start:this.streamPromise.promise,end:this.callEndPromise.promise},this.mqttClient&&this.mqttClient.oncallended?(console.log("RTCConnection._closeCall: Calling mqttClient.oncallended for "+this.target),this.mqttClient.oncallended(this.target)):console.warn("RTCConnection._closeCall: mqttClient.oncallended is not defined!")}onReceivedIceCandidate(e){this.peerConnection.remoteDescription?this.peerConnection.addIceCandidate(new RTCIceCandidate(e)).catch(e=>{console.warn("Error adding ICE candidate to peer connection:",e)}):(this.pendingIceCandidates||(this.pendingIceCandidates=[]),this.pendingIceCandidates.push(e),console.log("Remote description not set, storing ICE candidate as pending"))}onicecandidate(e){this.mqttClient.postPubliclyToMQTTServer("RTCIceCandidate",e.candidate)}onstreamicecandidate(e){e.candidate&&this.send("streamice",JSON.stringify(e.candidate))}ondatachannel(e){let t=e.channel;this.dataChannels[e.name]=t,t.onmessage=this.onmessage.bind(this)}ondatachannelerror(e,t){this.mqttClient.onrtcerror(t,e,this.target)}close(){this.closed||(this.peerConnection.close(),this.closed=!0,this.peerConnection=null,this.mqttClient.onrtcdisconnectedFromUser(this.target))}}class m extends h{constructor(e){e=e||{};let{name:t,userInfo:n,questionHandlers:s,handlers:i,load:o}=e;void 0===o&&(o=!0),e.load=!1,super(e),Object.assign(this.rtcHandlers,this.extraRTCHandlers),Object.assign(this.rtcHandlers,i||{});for(let[e,t]of Object.entries(this.rtcHandlers))this.rtcHandlers[e]=t.bind(this);s?this.questionHandlers=s:this.questionHandlers||(this.questionHandlers={}),this.questionPromises={},this.latestPings={},this.questionNumber=0,this.mqttConnected=new l,this.nextUserConnection=new l,this.nextUserDisconnectionPromises={},this.nextDMPromises={},this.nextChatPromises={},this.nextQuestionPromises={},this.nextAnswerPromises={},this.nextPingPromises={},this.nextPongPromises={},this.nextMQTTMessagePromises={},this.onConnectedToMQTT=this.onConnectedToMQTT.bind(this),this.sendRTCDM=this.sendRTCDM.bind(this),this.onRTCDM=this.onRTCDM.bind(this),this.sendRTCChat=this.sendRTCChat.bind(this),this.onRTCChat=this.onRTCChat.bind(this),this.onConnectedToUser=this.onConnectedToUser.bind(this),this.onDisconnectedFromUser=this.onDisconnectedFromUser.bind(this),this.sendRTCQuestion=this.sendRTCQuestion.bind(this),this.onRTCQuestion=this.onRTCQuestion.bind(this),this.respondToQuestion=this.respondToQuestion.bind(this),this.onRTCAnswer=this.onRTCAnswer.bind(this),this.pingEveryone=this.pingEveryone.bind(this),this.ping=this.ping.bind(this),this.receivedPing=this.receivedPing.bind(this),this.receivedPong=this.receivedPong.bind(this),this.nextUserDisconnection=this.nextUserDisconnection.bind(this),this.nextMQTTMessage=this.nextMQTTMessage.bind(this),this.nextAnswer=this.nextAnswer.bind(this),this.nextQuestion=this.nextQuestion.bind(this),this.nextChat=this.nextChat.bind(this),this.nextDM=this.nextDM.bind(this),this.nextPing=this.nextPing.bind(this),this.nextPong=this.nextPong.bind(this),this.addQuestionHandler=this.addQuestionHandler.bind(this),o&&this.load()}addQuestionHandler(e,t){this.questionHandlers[e]=t}extraRTCHandlers={dm:(e,t)=>{this.onRTCDM(e,t),this.nextDMPromises.anyone&&(this.nextDMPromises.anyone.resolve([e,t]),delete this.nextDMPromises.anyone),this.nextDMPromises[t]&&(this.nextDMPromises[t].resolve(e),delete this.nextDMPromises[t])},chat:(e,t)=>{this.onRTCChat(e,t),this.nextChatPromises.anyone&&(this.nextChatPromises.anyone.resolve([e,t]),delete this.nextChatPromises.anyone),this.nextChatPromises[t]&&(this.nextChatPromises[t].resolve(e),delete this.nextChatPromises[t])},question:(e,t)=>{this.onRTCQuestion(e,t),this.nextQuestionPromises.anyone&&(this.nextQuestionPromises.anyone.resolve([e,t]),delete this.nextQuestionPromises.anyone),this.nextQuestionPromises[t]&&(this.nextQuestionPromises[t].resolve(e),delete this.nextQuestionPromises[t])},answer:(e,t)=>{this.onRTCAnswer(e,t),this.nextAnswerPromises.anyone&&(this.nextAnswerPromises.anyone.resolve([e,t]),delete this.nextAnswerPromises.anyone),this.nextAnswerPromises[t]&&(this.nextAnswerPromises[t].resolve(e),delete this.nextAnswerPromises[t])},ping:(e,t)=>{this.sendOverRTC("pong",null,t),this.receivedPing(t),this.nextPingPromises.anyone&&(this.nextPingPromises.anyone.resolve([e,t]),delete this.nextPingPromises.anyone),this.nextPingPromises[t]&&(this.nextPingPromises[t].resolve(e),delete this.nextPingPromises[t])},pong:(e,t)=>{this.latestPings[t].resolve(),this.receivedPong(t),this.nextPongPromises.anyone&&(this.nextPongPromises.anyone.resolve([e,t]),delete this.nextPongPromises.anyone),this.nextPongPromises[t]&&(this.nextPongPromises[t].resolve(e),delete this.nextPongPromises[t])}};onConnectedToMQTT(){this.mqttConnected.resolve(),console.log("Connected to MQTT")}postPubliclyToMQTTServer(e,t){super.postPubliclyToMQTTServer(e,t)}onMQTTMessage(e,t,n,s){console.log("Received message from "+n+" on "+e,t),this.nextMQTTMessagePromises.anysubtopic&&(this.nextMQTTMessagePromises.anysubtopic.resolve([t,n,s]),delete this.nextMQTTMessagePromises.anysubtopic),this.nextMQTTMessagePromises[e]&&(this.nextMQTTMessagePromises[e].resolve([t,n,s]),delete this.nextMQTTMessagePromises[e]),super.onMQTTMessage(e,t,n,s)}onConnectedToUser(e){console.log("Connected to user ",e),this.nextUserConnection.resolve(e),this.nextUserConnection=new l}onDisconnectedFromUser(e){console.log("Disconnected from user ",e),this.nextUserDisconnection.resolve(e),this.nextUserDisconnectionPromises.anyone&&(this.nextUserDisconnectionPromises.anyone.resolve(e),delete this.nextUserDisconnectionPromises.anyone),this.nextUserDisconnectionPromises[e]&&(this.nextUserDisconnectionPromises[e].resolve(e),delete this.nextUserDisconnectionPromises[e])}sendRTCDM(e,t){this.sendOverRTC("dm",e,t)}onRTCDM(e,t){console.log("Received DM from "+t,e)}nextDM(e="anyone"){return this.nextDMPromises[e]=new l,this.nextDMPromises[e].promise}nextChat(e="anyone"){return this.nextChatPromises[e]=new l,this.nextChatPromises[e].promise}nextQuestion(e="anyone"){return this.nextQuestionPromises[e]=new l,this.nextQuestionPromises[e].promise}nextAnswer(e="anyone"){return this.nextAnswerPromises[e]=new l,this.nextAnswerPromises[e].promise}nextPing(e="anyone"){return this.nextPingPromises[e]=new l,this.nextPingPromises[e].promise}nextPong(e="anyone"){return this.nextPongPromises[e]=new l,this.nextPongPromises[e].promise}nextUserDisconnection(e="anyone"){return this.nextUserDisconnectionPromises[e]=new l,this.nextUserDisconnectionPromises[e].promise}nextMQTTMessage(e="anysubtopic"){return this.nextMQTTMessagePromises[e]=new l,this.nextMQTTMessagePromises[e].promise}sendRTCChat(e){this.sendOverRTC("chat",e)}onRTCChat(e,t){console.log("Received chat from "+t,e)}sendRTCQuestion(e,t,n){let s={topic:e,content:t},i=this.questionNumber;this.questionNumber++;let o=new l;this.questionPromises[i]=o;let a={n:i,question:s};return this.sendOverRTC("question",a,n),o.promise}onRTCQuestion(e,t){let{n:n,question:s}=e,i=this.respondToQuestion(s,t);i instanceof Promise?i.then(e=>{this.sendOverRTC("answer",{n:n,answer:e,question:s},t)}):this.sendOverRTC("answer",{n:n,answer:i,question:s},t)}respondToQuestion(e,t){let{topic:n,content:s}=e;if(this.questionHandlers[n])return this.questionHandlers[n](s,t);throw console.warn("No handler found for question "+n),new Error("No handler found for question "+n)}onRTCAnswer(e,t){let{n:n,answer:s}=e;this.questionPromises[n]?(this.questionPromises[n].resolve(s),delete this.questionPromises[n]):console.warn("No promise found for question "+n)}pingEveryone(){this.latestPings={};for(let e of this.connectedUsers)this.ping(e);return Promise.all(Object.values(this.latestPings).map(e=>e.promise))}ping(e){return this.latestPings[e]=new l,this.sendOverRTC("ping","ping",users),this.latestPings[e].promise}receivedPing(e){console.log("Received ping from "+e)}receivedPong(e){console.log("Received pong from "+e)}}class g extends m{constructor(e){e=e||{};let{name:t,userInfo:n,questionHandlers:s,handlers:i,load:o}=e;void 0===o&&(o=!0),e.load=!1,super(e),o&&this.load()}on(e,t){if("connectionrequest"===e)return this.shouldConnectToUser=t.bind(this),super.on(e,t);if("call"===e)return this.acceptCallFromUser=t.bind(this),super.on(e,t);if("callended"===e){const n=this.oncallended;return this.oncallended=e=>{n&&n.call(this,e)},super.on(e,t)}return"question"===e?(this.addQuestionHandler(e,t),super.on(e,t)):super.on(e,t)}shouldConnectToUser(e,t){return super.shouldConnectToUser(e,t)}changeName(e){super.changeName(e)}onNameChange(e,t){super.onNameChange(e,t),this.emit("namechange",e,t)}onConnectedToMQTT(){console.log("Connected to MQTT"),this.emit("mqttconnected")}onConnectedToUser(e){console.log("Connected to user ",e),this.emit("connectedtopeer",e)}onDisconnectedFromUser(e){console.log("Disconnected from user ",e),this.emit("disconnectedfrompeer",e)}onRTCDM(e,t){this.emit("dm",e,t)}onRTCChat(e,t){this.emit("chat",e,t)}addQuestionHandler(e,t){super.addQuestionHandler(e,t)}oncallconnected(e,{localStream:t,remoteStream:n}){this.emit("callconnected",e,{localStream:t,remoteStream:n})}pingEveryone(){let e=Date.now();return super.pingEveryone().then(()=>{console.log("Pinged everyone in "+(Date.now()-e)+"ms")})}ping(e){let t=Date.now();return super.ping(e).then(()=>{console.log("Pinged "+e+" in "+(Date.now()-t)+"ms")})}receivedPing(e){this.emit("ping",e)}get nextDMPromise(){return this.nextDM()}get nextChatPromise(){return this.nextChat()}get nextQuestionPromise(){return this.nextQuestion()}get nextAnswerPromise(){return this.nextAnswer()}get nextPingPromise(){return this.nextPing()}get nextPongPromise(){return this.nextPong()}get nextUserDisconnectionPromise(){return this.nextUserDisconnection()}get connectedUsers(){return this.connectionsToUsers()}disconnectFromUser(e){return super.disconnectFromUser(e),this.nextUserDisconnection(e)}getPeer(e){return new p(this,e)}get peers(){return Object.fromEntries(Object.entries(this.connectedUsers).map(e=>[e,new p(this,e)]))}get peerList(){return Object.values(this.peers)}send(e,t="chat",n){return super.sendOverRTC(t,e,n)}}class p{constructor(e,t){this.mqttClient=e,this.target=t}dm(e){return this.mqttClient.sendRTCDM(e,this.target)}chat(e){return this.mqttClient.sendRTCChat(e)}ask(e){return this.mqttClient.sendRTCQuestion(e,this.target)}ping(){return this.mqttClient.ping(this.target)}}class C{algorithm={name:"RSA-PSS",modulusLength:2048,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}};extractable=!0;keyUsages=["sign","verify"];constructor(e,t=!0,{storage:n=null,crypto:s=null}={}){if(this._name=null,this.name=e,this.storage=n||("undefined"!=typeof localStorage?{getItem:e=>localStorage.getItem(e),setItem:(e,t)=>localStorage.setItem(e,t),removeItem:e=>localStorage.removeItem(e)}:null),this.crypto=s||("undefined"!=typeof window&&window.crypto?window.crypto:null),!this.crypto||!this.crypto.subtle)throw new Error("Web Crypto API not available. Please provide a crypto instance via constructor.");this._loadKeys=this._loadKeys.bind(this),this.load=this.load.bind(this),this.generate=this.generate.bind(this),this._dumpKey=this._dumpKey.bind(this),this._loadPrivateKey=this._loadPrivateKey.bind(this),this._loadPublicKey=this._loadPublicKey.bind(this),this.sign=this.sign.bind(this),this.getChallengeString=this.getChallengeString.bind(this),this.verify=this.verify.bind(this),this.savePublicKey=this.savePublicKey.bind(this),this.savePublicKeyString=this.savePublicKeyString.bind(this),this.getPublicKey=this.getPublicKey.bind(this),this.clearOwnKeys=this.clearOwnKeys.bind(this),this.clearKnownHosts=this.clearKnownHosts.bind(this),this.getPeerNames=this.getPeerNames.bind(this),this.reset=this.reset.bind(this),this.loadedPromise=this.load(t)}load(e=!0){return this.loading=!0,this.loaded=!1,this.loadedPromise=this._loadKeys(e).then(e=>{if(this.storage){this._knownHostsStrings=JSON.parse(this.storage.getItem("knownHostsStrings")||"{}");for(let[e,t]of Object.entries(this._knownHostsStrings))e.startsWith("anon")&&delete this._knownHostsStrings[e];this._knownHostsKeys={}}else this._knownHostsStrings={},this._knownHostsKeys={};return this._privateKey=e.privateKey,this._publicKey=e.publicKey,this._privateKeyString=e.privateKeyString,this.publicKeyString=e.publicKeyString,this.storage&&(this.storage.setItem("privateKeyString",this._privateKeyString),this.storage.setItem("publicKeyString",this.publicKeyString)),this.loaded=!0,this.loading=!1,this.publicKeyString}),this.loadedPromise}_loadKeys(e=!0){if(!this.storage){if(!e)throw new Error("No storage available and generate is false");return this.generate()}let t=this.storage.getItem("privateKeyString"),n=this.storage.getItem("publicKeyString");if("force"!==e&&n&&t)return this._loadPrivateKey(t).then(e=>this._loadPublicKey(n).then(s=>({privateKey:e,publicKey:s,privateKeyString:t,publicKeyString:n})));if(!e)throw new Error("No keys found and generate is false");return this.generate()}generate(){return this.crypto.subtle.generateKey(this.algorithm,this.extractable,this.keyUsages).then(e=>this._dumpKey(e.privateKey).then(t=>(e.privateKeyString=t,this._dumpKey(e.publicKey).then(t=>(e.publicKeyString=t,e)))))}_dumpKey(e){return this.crypto.subtle.exportKey("jwk",e).then(JSON.stringify)}_loadPrivateKey(e){return this.crypto.subtle.importKey("jwk",JSON.parse(e),this.algorithm,this.extractable,["sign"])}_loadPublicKey(e){return this.crypto.subtle.importKey("jwk",JSON.parse(e),this.algorithm,this.extractable,["verify"])}getChallengeString(){return Array.from(this.crypto.getRandomValues(new Uint8Array(32))).map(e=>String.fromCharCode(e)).join("")}sign(e){return this.loading&&!this._loaded?this.loadedPromise.then(()=>this.sign(e)):this.crypto.subtle.sign({name:"RSA-PSS",saltLength:32},this._privateKey,new Uint8Array(e.split("").map(e=>e.charCodeAt(0))).buffer).then(e=>String.fromCharCode.apply(null,new Uint8Array(e)))}verify(e,t,n){return this._loadPublicKey(e).then(e=>this.crypto.subtle.verify({name:"RSA-PSS",saltLength:32},e,new Uint8Array(t.split("").map(e=>e.charCodeAt(0))).buffer,new Uint8Array(n.split("").map(e=>e.charCodeAt(0))).buffer))}getPeerNames(e){let t=[];if(!this._knownHostsStrings)return t;for(let[n,s]of Object.entries(this._knownHostsStrings))s===e&&t.push(n);return t}savePublicKey(e,t){return e=e.split("|")[0].split("(")[0].trim(),t instanceof CryptoKey?this._dumpKey(t).then(n=>(this.savePublicKey(e,n),this._knownHostsKeys[e]=t,!0)):this.savePublicKeyString(e,t)}savePublicKeyString(e,t){e=e.split("|")[0].split("(")[0].trim();let n=this.getPeerNames(t);if(n.length>0){if(n.includes(e))return this._knownHostsStrings[e]=t,this.storage&&this.storage.setItem("knownHostsStrings",JSON.stringify(this._knownHostsStrings)),!0;throw console.error("Public key already registered for another peer",n),new Error("Public key already registered for another peer")}return this._knownHostsStrings[e]=t,this.storage&&this.storage.setItem("knownHostsStrings",JSON.stringify(this._knownHostsStrings)),!0}getPublicKey(e){e=e.split("|")[0].split("(")[0].trim();let t=this._knownHostsKeys?.[e];if(t)return Promise.resolve(t);let n=this._knownHostsStrings?.[e];return n?this._loadPublicKey(n).then(t=>(this._knownHostsKeys||(this._knownHostsKeys={}),this._knownHostsKeys[e]=t,t)):Promise.resolve(null)}getPublicKeyString(e){return e=e.split("|")[0].split("(")[0].trim(),this._knownHostsStrings?.[e]||null}removePublicKey(e){e=e.split("|")[0].split("(")[0].trim(),this._knownHostsStrings&&delete this._knownHostsStrings[e],this._knownHostsKeys&&delete this._knownHostsKeys[e],this.storage&&this.storage.setItem("knownHostsStrings",JSON.stringify(this._knownHostsStrings||{}))}get knownHosts(){return this._knownHostsStrings?Object.entries(this._knownHostsStrings).map(([e,t])=>e+"|"+t):[]}clearOwnKeys(){this.storage&&(this.storage.removeItem("privateKeyString"),this.storage.removeItem("publicKeyString")),this._privateKey=null,this._publicKey=null,this._privateKeyString=null,this.publicKeyString=null}clearKnownHosts(){this.storage&&this.storage.removeItem("knownHostsStrings"),this._knownHostsKeys={},this._knownHostsStrings={}}reset(){this.clearOwnKeys(),this.clearKnownHosts()}get name(){return this._name}set name(e){if(e.includes("|"))throw new Error("Name cannot contain |");this._name=e}get identity(){if(!this.loaded)return null;return this.name.split("|")[0].split("(")[0].trim()+"|"+this.publicKeyString}register(e){let[t,n]=e.split("|");return this.savePublicKeyString(t,n)}}let f={reject:0,promptandtrust:1,connectandprompt:2,connectandtrust:3},y={trusted:0,nonsuspicious:1,slightlyodd:2,odd:3,veryodd:4};class v extends g{constructor(e){const t=(e=e||{})instanceof n?e:new n(e),s=t.getConfig(),i=!1!==e.generate,o=!1!==s.load,a=e.trustMode||s.trustMode||"strict",r=t.name,l=s.connection?.autoAcceptConnections??!1;super({...e,load:!1});const c=r||(this.name?this.name.split("(")[0]:"User"),d=this.storage||("undefined"!=typeof localStorage?{getItem:e=>localStorage.getItem(e),setItem:(e,t)=>localStorage.setItem(e,t),removeItem:e=>localStorage.removeItem(e)}:null),h=s.crypto||("undefined"!=typeof window&&window.crypto?window.crypto:null);if(this.keys=new C(c,i,{storage:d,crypto:h}),this.validatedPeers=[],void 0===a&&(a="strict"),this.trustConfigs[a]?this.trustConfig=this.trustConfigs[a]:this.trustConfig=a,!this.trustConfig||Object.keys(this.userCategories).map(e=>this.trustConfig[e]).some(e=>void 0===e))throw new Error("Invalid trust mode");this.completeUserInfo={},this.shouldConnectToUser=this.shouldConnectToUser.bind(this),this.checkTrust=this.checkTrust.bind(this),this._getFullUserInfo=this._getFullUserInfo.bind(this),this.trust=this.trust.bind(this),this.register=this.register.bind(this),this.challenge=this.challenge.bind(this),this.untrust=this.untrust.bind(this),this.autoAcceptConnections=l,this.addQuestionHandler("identify",this._returnPublicKey.bind(this)),this.addQuestionHandler("challenge",this._sign.bind(this)),this.on("connectedtopeer",e=>{this.validatedPeers.includes(e)||setTimeout(()=>{this.trustOrChallenge.bind(this)(e)},1e3)}),o&&this.keys.loadedPromise.then(()=>{this.userInfo.publicKeyString=this.keys.publicKeyString,this.load()})}verifyUser(e,t,n){return console.log("Verifying user",e,t,n,this.validatedPeers),!(!["question","answer"].includes(e)||!["identify","challenge"].includes(t.question.topic))||this.validatedPeers.includes(n)}_getFullUserInfo(e,t){let n=e.split("|")[0].split("(")[0].trim();if(n.startsWith("anon"))return{peerName:e,bareName:n,userInfo:t,providedPubKey:!1,knownPubKey:!1,knownName:!1,otherNamesForPubKey:[],otherPubKeyForName:null,completedChallenge:!1,explanation:"anonymous",suspiciousness:y.nonsuspicious,category:"nevermet",hint:"anon"};let s=!!t.publicKeyString,i=s?this.keys.getPeerNames(t.publicKeyString):[],o=this.keys.getPublicKeyString(n),a={peerName:e,bareName:n,userInfo:t,providedPubKey:s,knownPubKey:i.length>0,knownName:i.includes(n),otherNamesForPubKey:i.filter(e=>e!==n),otherPubKeyForName:o&&o!==t.publicKeyString?o:null,completedChallenge:!1},r=this.categorizeUser(a);a.explanation=r.explanation,a.suspiciousness=r.suspiciousness,a.category=r.category;let l="";return"theoneandonly"===a.category?l="":["knownwithknownaliases","possiblenamechange","possiblesharedpubkey"].includes(a.category)?l=` who is known as ${a.otherNamesForPubKey.join(", ")}`:"nameswapcollision"===a.category?l=`it appears ${a.otherNamesForPubKey[0]} (who you know) is using ${e}'s public key to impersonate them'`:"pretender"===a.category?l=` who is pretending to be ${a.otherNamesForPubKey[0]}`:"nevermet"===a.category&&(l=" who you have not met"),l=l?` (${l})`:"",a.hint=l,a}shouldConnectToUser(e,t){console.log("Checking if we should connect to user",e,t);let n=this._getFullUserInfo(e,t);console.log("info",n);let s=this.checkTrust(n);return n.trustLevel=s,n.trustLevelString=Object.keys(this.trustLevels).find(e=>this.trustLevels[e]===s),this.completeUserInfo[e]&&this.isConnectedToUser(e)?(console.warn("Rejecting connection to "+e+" because we are already connected to someone with that name"),Promise.resolve(!1)):(this.completeUserInfo[e]=n,s===f.reject?(console.error("Rejecting connection to "+e),Promise.resolve(!1)):[f.doubleprompt,f.promptandtrust].includes(s)?this.connectionrequest(e,n).then(t=>(t?console.log("Decided to connect to "+e):console.log("Decided not to connect to "+e),t),e=>(console.log("Error in connection request",e),!1)):(console.log("will connect to "+e),Promise.resolve(!0)))}trustLevels=f;suspicionLevels=y;userCategories={theoneandonly:{knownPubKey:!0,knownName:!0,otherNamesForPubKey:!1,otherPubKeyForName:!1,explanation:"you know this person by the public key provided and don't now anyone else by this name or public key",suspiciousness:y.trusted,category:"theoneandonly"},knownwithknownaliases:{knownPubKey:!0,knownName:!0,otherNamesForPubKey:!0,otherPubKeyForName:!1,explanation:"you know this person by the public key provided, but you also know them by other names",suspiciousness:y.slightlyodd,category:"knownwithknownaliases"},possiblenamechange:{knownPubKey:!0,knownName:!1,otherNamesForPubKey:1,otherPubKeyForName:!1,explanation:"you recognize the public key but know it by a different name",suspiciousness:y.slightlyodd,category:"possiblenamechange"},possiblesharedpubkey:{knownPubKey:!0,knownName:!1,otherNamesForPubKey:!0,otherPubKeyForName:!1,explanation:"you recognize the public key but know it by more than one other name",suspiciousness:y.slightlyodd,category:"possiblesharedpubkey"},nameswapcollision:{knownPubKey:!0,knownName:!1,otherNamesForPubKey:!0,otherPubKeyForName:!0,explanation:"someone you know tried to change their name to the name of someone else you know",suspiciousness:y.odd,category:"nameswapcollision"},pretender:{knownPubKey:!1,knownName:!1,otherNamesForPubKey:!1,otherPubKeyForName:!0,explanation:"someone you don't know is using the name of someone you do know",suspiciousness:y.veryodd,category:"pretender"},nevermet:{knownPubKey:!1,knownName:!1,otherNamesForPubKey:!1,otherPubKeyForName:!1,explanation:"you don't know anyone with this pub key or name, you probably just haven't met yet",suspiciousness:y.notsuspicious,category:"nevermet"}};trustConfigs={alwaysprompt:{theoneandonly:f.promptandtrust,knownwithknownaliases:f.promptandtrust,possiblenamechange:f.promptandtrust,possiblesharedpubkey:f.promptandtrust,nameswapcollision:f.promptandtrust,pretender:f.promptandtrust,nevermet:f.promptandtrust},strict:{theoneandonly:f.connectandtrust,knownwithknownaliases:f.promptandtrust,possiblenamechange:f.promptandtrust,possiblesharedpubkey:f.promptandtrust,nameswapcollision:f.promptandtrust,pretender:f.promptandtrust,nevermet:f.promptandtrust},strictandquiet:{theoneandonly:f.connectandtrust,knownwithknownaliases:f.reject,possiblenamechange:f.reject,possiblesharedpubkey:f.reject,nameswapcollision:f.reject,pretender:f.reject,nevermet:f.promptandtrust},moderate:{theoneandonly:f.connectandtrust,knownwithknownaliases:f.connectandtrust,possiblenamechange:f.connectandtrust,possiblesharedpubkey:f.connectandtrust,nameswapcollision:f.promptandtrust,pretender:f.promptandtrust,nevermet:f.promptandtrust},moderateandquiet:{theoneandonly:f.connectandtrust,knownwithknownaliases:f.connectandtrust,possiblenamechange:f.connectandtrust,possiblesharedpubkey:f.connectandtrust,nameswapcollision:f.reject,pretender:f.reject,nevermet:f.promptandtrust},lax:{theoneandonly:f.connectandtrust,knownwithknownaliases:f.connectandtrust,possiblenamechange:f.connectandtrust,possiblesharedpubkey:f.connectandtrust,nameswapcollision:f.promptandtrust,pretender:f.promptandtrust,nevermet:f.connectandtrust},unsafe:{theoneandonly:f.connectandtrust,knownwithknownaliases:f.connectandtrust,possiblenamechange:f.connectandtrust,possiblesharedpubkey:f.connectandtrust,nameswapcollision:f.connectandtrust,pretender:f.connectandtrust,nevermet:f.connectandtrust},rejectall:{theoneandonly:f.reject,knownwithknownaliases:f.reject,possiblenamechange:f.reject,possiblesharedpubkey:f.reject,nameswapcollision:f.reject,pretender:f.reject,nevermet:f.reject}};categorizeUser(e){if(e.knownPubKey){if(e.knownName){if(e.otherPubKeyForName)throw new Error("knownName should mean that this name matches the pubkey so therefore otherPubKeyForName should be null");return 0===e.otherNamesForPubKey.length?this.userCategories.theoneandonly:this.userCategories.knownwithknownaliases}if(0===e.otherNamesForPubKey.length)throw new Error("knownPubKey should mean that this pubkey matches at least one name so if knownName is false then there should be at least one other name for this pubkey");return 1===e.otherNamesForPubKey.length?e.otherPubKeyForName?this.userCategories.nameswapcollision:this.userCategories.possiblenamechange:e.otherPubKeyForName?this.userCategories.nameswapcollision:this.userCategories.possiblesharedpubkey}return e.otherPubKeyForName?this.userCategories.pretender:this.userCategories.nevermet}checkTrust({peerName:e,bareName:t,userInfo:n,providedPubKey:s,peerNames:i,knownPubKey:o,knownName:a,otherNamesForPubKey:r,otherPubKeyForName:l,completedChallenge:c,explanation:d,suspiciousness:h,category:u}){return console.log("Checking trust for "+e,u,this.trustConfig),this.trustConfig[u]}connectionrequest(e,t){if(this.autoAcceptConnections)return console.log("Auto-accepting connection request from",e),Promise.resolve(!0);let n=confirm("Do you want to connect to "+e+"?");return Promise.resolve(n)}trustOrChallenge(e){this.keys.getPublicKey(e).then(t=>{if(t)this.challenge(e);else{console.log("No public key found for "+e);let t=this.completeUserInfo[e];if(!t){t=this._getFullUserInfo(e,{});const n=this.checkTrust(t);t.trustLevel=n,t.trustLevelString=Object.keys(this.trustLevels).find(e=>this.trustLevels[e]===n),this.completeUserInfo[e]=t}const n=t.trustLevel;if([this.trustLevels.reject].includes(n))return console.error("Rejecting connection to "+e),void this.untrust(e);if([this.trustLevels.connectandprompt].includes(n))return void this.connectionrequest(e,t).then(t=>{t?this.trust(e):this.untrust(e)});[this.trustLevels.promptandtrust,this.trustLevels.connectandtrust].includes(n)&&this.trust(e)}})}_returnPublicKey(e,t){return console.log("Challenge received from "+t),this.keys.sign(e).then(e=>{let n={publicKeyString:this.keys.publicKeyString,signature:e};return console.log("Returning public key to "+t,n),n})}reset(){this.keys.reset(),this.validatedPeers=[]}trust(e){let t=this.keys.getPublicKeyString(e),n=this.keys.getChallengeString();return this.sendRTCQuestion("identify",n,e).then(({publicKeyString:s,signature:i})=>{if(t&&t!==s)throw console.error("Public key changed for "+e,t,s),new Error("Public key changed for "+e);return this.keys.verify(s,i,n).then(t=>{if(t){console.log("Signature valid for "+e+", trusting and saving public key");const t=this.keys.getPeerNames(s);return t.length>0&&!t.includes(e)&&(console.log("Public key already registered to",t,"updating to",e),t.forEach(e=>{delete this.keys._knownHostsStrings[e]}),this.keys.storage&&this.keys.storage.setItem("knownHostsStrings",JSON.stringify(this.keys._knownHostsStrings))),this.keys.savePublicKeyString(e,s),this.validatedPeers.includes(e)||(this.validatedPeers.push(e),this.onValidatedPeer(e,!0)),!0}return console.error("Signature invalid for "+e),this.untrust(e),this.onValidationFailed(e),!1})})}challenge(e){let t=this.keys.getPublicKeyString(e),n=this.keys.getChallengeString();return this.sendRTCQuestion("challenge",n,e).then(s=>this.keys.verify(t,s,n).then(t=>(console.log("Signature valid for "+e,t),this.validatedPeers.includes(e)||(this.validatedPeers.push(e),console.log("Validated peers",this.validatedPeers),this.onValidatedPeer(e)),t),t=>{throw console.error("Error verifying signature of "+e,t),this.untrust(e),this.onValidationFailed(e),t}))}on(e,t){return"connectionrequest"===e?(this.connectionrequest=t,super.on(e,t)):super.on(e,t)}onValidatedPeer(e,t=!1){t&&console.log("Trusting peer "+e+" is who they say they are."),console.log("Peer "+e+" validated"),this.emit("validation",e,t)}onValidationFailed(e,t){console.error("Peer "+e+" validation failed"+(t?": "+t:"")),this.emit("validationfailure",e,t)}untrust(e){this.keys.removePublicKey(e),console.error("Untrusting peer "+e,this.validatedPeers),this.validatedPeers.includes(e)&&(this.validatedPeers=this.validatedPeers.filter(t=>t!==e)),console.error("Disconnecting from untrusted peer "+e,this.validatedPeers),this.disconnectFromUser(e)}_sign(e,t){return this.keys.sign(e)}register(e){return this.keys.register(e)}}class b{setStream(e){throw new Error("setStream must be implemented")}getStream(){throw new Error("getStream must be implemented")}show(){}hide(){}setMuted(e){}isMuted(){return!1}setAutoplay(e){}setPlaysinline(e){}getElement(){return null}destroy(){}}class w extends b{constructor(e={}){super(),this.options={autoplay:!1!==e.autoplay,playsinline:!1!==e.playsinline,muted:e.muted||!1,...e},this.element=document.createElement("video"),this.element.autoplay=this.options.autoplay,this.element.playsinline=this.options.playsinline,this.element.muted=this.options.muted,this.element.style.width="100%",this.element.style.height="auto",this.element.style.display="block"}setStream(e){e&&e instanceof MediaStream?this.element.srcObject=e:null===e?this.element.srcObject=null:console.warn("VideoElement.setStream: Invalid stream provided",e)}getStream(){return this.element.srcObject}show(){this.element.style.display="block"}hide(){this.element.style.display="none"}setMuted(e){this.element.muted=e}isMuted(){return this.element.muted}setAutoplay(e){this.element.autoplay=e}setPlaysinline(e){this.element.playsinline=e}getElement(){return this.element}destroy(){this.element.srcObject&&(this.element.srcObject.getTracks().forEach(e=>e.stop()),this.element.srcObject=null),this.element.parentNode&&this.element.parentNode.removeChild(this.element)}}class S{constructor(e,t={}){if(new.target===S)throw new Error("VideoStreamDisplayBase is abstract and cannot be instantiated directly");if(!e)throw new Error("VideoStreamDisplayBase requires a container");this.container=e,this.options={localVideoSize:t.localVideoSize||"30%",localVideoPosition:t.localVideoPosition||"top-right",VideoClass:t.VideoClass,...t},this.activeStreams={}}setStreams(e,{localStream:t,remoteStream:n}){throw new Error("setStreams must be implemented by subclass")}removeStreams(e){throw new Error("removeStreams must be implemented by subclass")}show(){this.container&&this.container.style&&this.hasActiveStreams()&&(this.container.style.display="block")}hide(){this.container&&this.container.style&&(this.container.style.display="none")}hasActiveStreams(){return Object.keys(this.activeStreams).length>0}getActivePeers(){return Object.keys(this.activeStreams)}removeAllStreams(){Object.keys(this.activeStreams).forEach(e=>this.removeStreams(e))}_setupTrackEndHandlers(e,t,n){const s=this.activeStreams[e];if(!s)return;s.trackEndHandlers&&s.trackEndHandlers.forEach(e=>{e.track&&e.track.onended&&(e.track.onended=null)}),s.trackEndHandlers=[];const i=()=>{console.log(`Stream track ended for ${e}`),this.removeStreams(e)};n&&n instanceof MediaStream&&"function"==typeof n.getTracks&&n.getTracks().forEach(e=>{e.onended=i,s.trackEndHandlers.push({track:e,type:"remote"})}),t&&t instanceof MediaStream&&"function"==typeof t.getTracks&&t.getTracks().forEach(e=>{e.onended=i,s.trackEndHandlers.push({track:e,type:"local"})})}_stopStreamTracks(e){e&&e instanceof MediaStream&&"function"==typeof e.getTracks&&e.getTracks().forEach(e=>{e.stop()})}_setupStyles(){}_createVideoContainer(e){throw new Error("_createVideoContainer must be implemented by subclass")}}class T extends S{constructor(e,t={}){if(super(e,{localVideoSize:t.localVideoSize||"30%",localVideoPosition:t.localVideoPosition||"top-right",VideoClass:t.VideoClass||w,...t}),this.VideoClass=this.options.VideoClass,!this.VideoClass||"function"!=typeof this.VideoClass)throw new Error("VideoClass must be a class implementing VideoInterface");this.container&&!this.container.classList.contains("video-stream-display-container")&&this.container.classList.add("video-stream-display-container"),this._setupStyles(),this._localStream=null}_setupStyles(){const e=this.container.getRootNode?this.container.getRootNode():document;if(e.querySelector){const t=e.querySelector("style[data-video-stream-display]");if(t){if("2"===t.getAttribute("data-style-version"))return;t.parentNode&&t.parentNode.removeChild(t)}}const t=document.createElement("style");if(t.setAttribute("data-video-stream-display","true"),t.setAttribute("data-style-version","2"),t.textContent="\n      .video-stream-display-container {\n        display: none;\n        gap: 10px;\n        width: 100%;\n        padding: 10px;\n        min-height: 300px;\n      }\n      .video-stream-display-container.is-active {\n        display: grid !important;\n      }\n      .video-stream-display-container.count-1 {\n        grid-template-columns: 1fr;\n        grid-template-rows: 1fr;\n      }\n      /* Two remote participants: place both side by side */\n      .video-stream-display-container.count-2 {\n        grid-template-columns: repeat(2, minmax(0, 1fr));\n        grid-template-rows: 1fr;\n      }\n      /* 3 people: three equal columns */\n      .video-stream-display-container.count-3 {\n        grid-template-columns: repeat(3, minmax(0, 1fr));\n        grid-template-rows: 1fr;\n      }\n      /* 4 people: 2x2 grid */\n      .video-stream-display-container.count-4 {\n        grid-template-columns: repeat(2, minmax(0, 1fr));\n        grid-template-rows: repeat(2, minmax(0, 1fr));\n      }\n      /* 5-6 people: 2x3 grid */\n      .video-stream-display-container.count-5,\n      .video-stream-display-container.count-6 {\n        grid-template-columns: repeat(3, minmax(0, 1fr));\n        grid-template-rows: repeat(2, minmax(0, 1fr));\n      }\n      /* 7-9 people: 3x3 grid */\n      .video-stream-display-container.count-7,\n      .video-stream-display-container.count-8,\n      .video-stream-display-container.count-9 {\n        grid-template-columns: repeat(3, 1fr);\n        grid-template-rows: repeat(3, 1fr);\n      }\n      /* 10+ people: auto-fit grid */\n      .video-stream-display-container.count-10-plus {\n        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));\n        grid-auto-rows: minmax(150px, 1fr);\n      }\n      /* Two-person overlay layout */\n      .video-stream-display-container.two-person-overlay {\n        grid-template-columns: 1fr;\n        grid-template-rows: 1fr;\n      }\n      .video-stream-display-container.two-person-overlay .video-stream-container {\n        position: relative;\n      }\n      .video-stream-container {\n        position: relative;\n        width: 100%;\n        aspect-ratio: 16 / 9;\n        background: #000;\n        border-radius: 5px;\n        overflow: hidden;\n        border: 2px solid #333;\n      }\n      .video-stream-container video {\n        width: 100%;\n        height: 100%;\n        display: block;\n        object-fit: cover;\n      }\n      .video-stream-remote {\n        width: 100%;\n        height: 100%;\n      }\n      .video-stream-local {\n        display: none;\n        width: 0;\n        height: 0;\n        opacity: 0;\n        pointer-events: none;\n      }\n      .video-stream-display-container.two-person-overlay .video-stream-container:first-child .video-stream-local {\n        display: block !important;\n        position: absolute;\n        width: 30%;\n        max-width: 30%;\n        height: auto;\n        aspect-ratio: 16 / 9;\n        top: 10px;\n        right: 10px;\n        border: 2px solid white;\n        box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);\n        border-radius: 5px;\n        background: #000;\n        opacity: 1 !important;\n        pointer-events: auto !important;\n        z-index: 10;\n      }\n      .video-stream-label {\n        position: absolute;\n        bottom: 10px;\n        left: 10px;\n        background: rgba(0, 0, 0, 0.7);\n        color: white;\n        padding: 4px 8px;\n        border-radius: 4px;\n        font-size: 12px;\n        z-index: 11;\n        pointer-events: none;\n      }\n    ",e instanceof ShadowRoot)e.appendChild(t);else if(e===document||e===document.documentElement)document.head.appendChild(t);else try{e.appendChild?e.appendChild(t):document.head.appendChild(t)}catch(e){document.head.appendChild(t)}}setStreams(e,{localStream:t,remoteStream:n}){if(!e)throw new Error("peerName is required");this.container.classList.contains("video-stream-display-container")||this.container.classList.add("video-stream-display-container");let s=this.activeStreams[e];if(!s||!s.container){const{container:t,remoteVideo:n,localVideo:i,label:o}=this._createVideoContainer(e);this.container.appendChild(t),s={container:t,remoteVideo:n,localVideo:i,label:o,streams:{},trackEndHandlers:[]},this.activeStreams[e]=s}n&&n instanceof MediaStream?(s.remoteVideo.setStream(n),s.remoteVideo.show(),s.label&&(s.label.textContent=e,s.label.style.display="block")):(s.remoteVideo.setStream(null),s.label&&(s.label.style.display="none")),t instanceof MediaStream?this._localStream=t:null===t&&(this._localStream=null),this.activeStreams[e].streams.local=t,this.activeStreams[e].streams.remote=n,this._setupTrackEndHandlers(e,t,n),this._refreshLocalVideoLayout(),this._updateGridLayout(),this._updateContainerVisibility()}_refreshLocalVideoLayout(){const e=Object.keys(this.activeStreams).filter(e=>"__local__"!==e),t=e.length,n=this._localStream instanceof MediaStream;for(const t of e){const e=this.activeStreams[t];if(e&&e.localVideo){e.localVideo.setStream(null),e.localVideo.hide();const t=e.localVideo.getElement?e.localVideo.getElement():null;t&&(t.style.display="none")}}if(n&&1===t){const t=e[0],n=t?this.activeStreams[t]:null;if(n&&n.localVideo){n.localVideo.setStream(this._localStream),n.localVideo.show();const e=n.localVideo.getElement?n.localVideo.getElement():null;e&&(e.style.display="block")}this._deleteStreamData("__local__")}else n&&t>=2?this._updateLocalVideoInGrid(this._localStream):this._deleteStreamData("__local__")}_updateLocalVideoInGrid(e){const t="__local__";let n=this.activeStreams[t];if(!n||!n.container){const{container:s,remoteVideo:i,label:o}=this._createVideoContainer(t);s.classList.add("local-video-container");const a=this.container.firstChild;a?this.container.insertBefore(s,a):this.container.appendChild(s),n={container:s,remoteVideo:i,localVideo:null,label:o,streams:{local:e,remote:null},trackEndHandlers:[]},this.activeStreams[t]=n}n.remoteVideo&&(n.remoteVideo.setStream(e),n.remoteVideo.show(),n.label&&(n.label.textContent="You",n.label.style.display="block"))}_updateGridLayout(){const e=Object.keys(this.activeStreams).filter(e=>"__local__"!==e),t=void 0!==this.activeStreams.__local__,n=e.length,s=n+(t?1:0);if(Array.from(this.container.classList).filter(e=>e.startsWith("count-")).forEach(e=>this.container.classList.remove(e)),this.container.classList.remove("two-person-overlay"),1===n&&!t&&this._localStream instanceof MediaStream)return this.container.classList.add("count-1"),this.container.classList.add("two-person-overlay"),void console.log("Updated grid layout: two-person overlay mode");s<=1?this.container.classList.add("count-1"):2===s?this.container.classList.add("count-2"):3===s?this.container.classList.add("count-3"):4===s?this.container.classList.add("count-4"):5===s||6===s||s>=7&&s<=9?this.container.classList.add(`count-${s}`):s>=10&&this.container.classList.add("count-10-plus");const i=t?1:0;console.log(`Updated grid layout: ${s} tiles (${n} remote + ${i} local)`)}_createVideoContainer(e){const t=document.createElement("div");t.className="video-stream-container",t.setAttribute("data-peer",e);const n=new this.VideoClass({autoplay:!0,playsinline:!0,muted:!1}),s=n.getElement();s&&(s.className="video-stream-remote",s.setAttribute("data-peer",e),s.setAttribute("data-type","remote"),t.appendChild(s));const i=document.createElement("div");i.className="video-stream-label",i.textContent=e,i.setAttribute("data-peer",e),t.appendChild(i);const o=new this.VideoClass({autoplay:!0,playsinline:!0,muted:!0}),a=o.getElement();return a&&(a.className="video-stream-local",a.setAttribute("data-peer",e),a.setAttribute("data-type","local"),t.appendChild(a)),{container:t,remoteVideo:n,localVideo:o,label:i}}_deleteStreamData(e){const t=this.activeStreams[e];t&&(t.streams&&this._stopStreamTracks(t.streams.remote),t.trackEndHandlers&&t.trackEndHandlers.forEach(e=>{e.track&&e.track.onended&&(e.track.onended=null)}),t.remoteVideo&&"function"==typeof t.remoteVideo.setStream&&(t.remoteVideo.setStream(null),"function"==typeof t.remoteVideo.destroy&&t.remoteVideo.destroy()),t.localVideo&&"function"==typeof t.localVideo.setStream&&(t.localVideo.setStream(null),"function"==typeof t.localVideo.destroy&&t.localVideo.destroy()),t.container&&t.container.parentNode&&t.container.parentNode.removeChild(t.container),delete this.activeStreams[e])}removeStreams(e){this.activeStreams[e]&&(this._deleteStreamData(e),this._refreshLocalVideoLayout(),this._updateGridLayout(),this._updateContainerVisibility())}_updateContainerVisibility(){const e=Object.keys(this.activeStreams).length>0;this.container.classList.toggle("is-active",e)}}class M{constructor(e,t={}){if(!e)throw new Error("AudioStreamDisplay requires a container element");this.container=e,this.options={showVisualIndicator:!1!==t.showVisualIndicator,showWaveform:t.showWaveform||!1,...t},this.activeStreams={},this._setupStyles()}_setupStyles(){const e=this.container.getRootNode?this.container.getRootNode():document;if(e.querySelector&&e.querySelector("style[data-audio-stream-display]"))return;const t=document.createElement("style");if(t.setAttribute("data-audio-stream-display","true"),t.textContent="\n      .audio-stream-container {\n        display: flex;\n        align-items: center;\n        gap: 10px;\n        padding: 8px;\n        margin-bottom: 5px;\n        background: rgba(0, 0, 0, 0.05);\n        border-radius: 5px;\n        border-left: 3px solid #4CAF50;\n      }\n      .audio-stream-indicator {\n        width: 12px;\n        height: 12px;\n        border-radius: 50%;\n        background: #4CAF50;\n        animation: pulse 2s infinite;\n      }\n      @keyframes pulse {\n        0%, 100% { opacity: 1; }\n        50% { opacity: 0.5; }\n      }\n      .audio-stream-label {\n        font-size: 0.9em;\n        color: #333;\n        flex: 1;\n      }\n      .audio-stream-controls {\n        display: flex;\n        gap: 5px;\n      }\n      .audio-stream-mute-btn {\n        padding: 4px 8px;\n        border: 1px solid #ccc;\n        border-radius: 3px;\n        background: white;\n        cursor: pointer;\n        font-size: 0.8em;\n      }\n      .audio-stream-mute-btn:hover {\n        background: #f0f0f0;\n      }\n      .audio-stream-mute-btn.muted {\n        background: #ffebee;\n        border-color: #f44336;\n      }\n      .audio-stream-element {\n        display: none; /* Hide audio element, we just use it for playback */\n      }\n    ",e instanceof ShadowRoot)e.appendChild(t);else if(e===document||e===document.documentElement)document.head.appendChild(t);else try{e.appendChild?e.appendChild(t):document.head.appendChild(t)}catch(e){document.head.appendChild(t)}}setStreams(e,{localStream:t,remoteStream:n}){if(!e)throw new Error("peerName is required");let s=this.activeStreams[e]?.container;s||(s=this._createAudioContainer(e),this.container.appendChild(s),this.activeStreams[e]?this.activeStreams[e].container=s:this.activeStreams[e]={container:s,streams:{},trackEndHandlers:[],muted:!1});const i=s.querySelector('.audio-stream-element[data-type="remote"]'),o=s.querySelector('.audio-stream-element[data-type="local"]');n&&i&&(i.srcObject=n,i.play().catch(e=>{console.warn("Could not play remote audio:",e)})),t&&o&&(o.srcObject=t,o.muted=!0,o.play().catch(e=>{console.warn("Could not play local audio:",e)})),this.activeStreams[e].streams.local=t,this.activeStreams[e].streams.remote=n,this._setupTrackEndHandlers(e,t,n),"none"===this.container.style.display&&(this.container.style.display="block")}_createAudioContainer(e){const t=document.createElement("div");if(t.className="audio-stream-container",t.setAttribute("data-peer",e),this.options.showVisualIndicator){const e=document.createElement("div");e.className="audio-stream-indicator",t.appendChild(e)}const n=document.createElement("div");n.className="audio-stream-label",n.textContent=`ðŸ”Š ${e}`,t.appendChild(n);const s=document.createElement("div");s.className="audio-stream-controls";const i=document.createElement("button");i.className="audio-stream-mute-btn",i.textContent="Mute",i.onclick=()=>this._toggleMute(e),s.appendChild(i),t.appendChild(s);const o=document.createElement("audio");o.className="audio-stream-element",o.autoplay=!0,o.setAttribute("data-peer",e),o.setAttribute("data-type","remote");const a=document.createElement("audio");return a.className="audio-stream-element",a.autoplay=!0,a.muted=!0,a.setAttribute("data-peer",e),a.setAttribute("data-type","local"),t.appendChild(o),t.appendChild(a),t}_toggleMute(e){const t=this.activeStreams[e];if(!t)return;const n=t.container.querySelector('.audio-stream-element[data-type="remote"]');if(!n)return;t.muted=!t.muted,n.muted=t.muted;const s=t.container.querySelector(".audio-stream-mute-btn");s&&(s.textContent=t.muted?"Unmute":"Mute",s.classList.toggle("muted",t.muted))}_setupTrackEndHandlers(e,t,n){this.activeStreams[e].trackEndHandlers&&this.activeStreams[e].trackEndHandlers.forEach(e=>{e.track&&e.track.onended&&(e.track.onended=null)}),this.activeStreams[e].trackEndHandlers=[];const s=()=>{console.log(`Audio stream track ended for ${e}`),this.removeStreams(e)};n&&n instanceof MediaStream&&"function"==typeof n.getTracks&&n.getTracks().forEach(t=>{t.onended=s,this.activeStreams[e].trackEndHandlers.push({track:t,type:"remote"})}),t&&t instanceof MediaStream&&"function"==typeof t.getTracks&&t.getTracks().forEach(t=>{t.onended=s,this.activeStreams[e].trackEndHandlers.push({track:t,type:"local"})})}removeStreams(e){const t=this.activeStreams[e];if(!t)return;t.streams&&t.streams.remote&&t.streams.remote.getTracks().forEach(e=>{e.stop()}),t.trackEndHandlers&&t.trackEndHandlers.forEach(e=>{e.track&&e.track.onended&&(e.track.onended=null)});const n=t.container?.querySelector('.audio-stream-element[data-type="remote"]'),s=t.container?.querySelector('.audio-stream-element[data-type="local"]');n&&(n.srcObject=null),s&&(s.srcObject=null),t.container&&t.container.parentNode&&t.container.parentNode.removeChild(t.container),delete this.activeStreams[e],0===Object.keys(this.activeStreams).length&&(this.container.style.display="none")}removeAllStreams(){Object.keys(this.activeStreams).forEach(e=>this.removeStreams(e))}hasActiveStreams(){return Object.keys(this.activeStreams).length>0}getActivePeers(){return Object.keys(this.activeStreams)}show(){this.hasActiveStreams()&&(this.container.style.display="block")}hide(){this.container.style.display="none"}}class x{start(){throw new Error("start must be implemented")}stop(){throw new Error("stop must be implemented")}isRinging(){return!1}}class k extends x{constructor(e={}){super(),this.options={volume:void 0!==e.volume?e.volume:.25,...e},this.audioContext=null,this.oscillator1=null,this.oscillator2=null,this.gainNode=null,this.isRinging=!1,this.ringInterval=null,this._initAudioContext()}_initAudioContext(){try{const e=window.AudioContext||window.webkitAudioContext;e&&(this.audioContext=new e)}catch(e){console.warn("Web Audio API not supported:",e)}}async _resumeAudioContext(){if(this.audioContext&&"suspended"===this.audioContext.state)try{await this.audioContext.resume()}catch(e){console.warn("Failed to resume audio context:",e)}}_startOscillators(){if(!this.audioContext)return;const e=this.audioContext.currentTime,t=.15;this.gainNode=this.audioContext.createGain(),this.gainNode.gain.value=this.options.volume,this.gainNode.connect(this.audioContext.destination),this.oscillator1=this.audioContext.createOscillator(),this.oscillator1.type="sine",this.oscillator1.frequency.value=440,this.oscillator1.connect(this.gainNode),this.oscillator2=this.audioContext.createOscillator(),this.oscillator2.type="sine",this.oscillator2.frequency.value=554.37;const n=this.audioContext.createGain();n.gain.value=this.options.volume,n.connect(this.audioContext.destination),this.oscillator2.connect(n),this.oscillator1.start(e),this.oscillator1.stop(e+t),this.oscillator2.start(e+t),this.oscillator2.stop(e+.3)}_stopOscillators(){if(this.oscillator1){try{this.oscillator1.stop()}catch(e){}this.oscillator1=null}if(this.oscillator2){try{this.oscillator2.stop()}catch(e){}this.oscillator2=null}this.gainNode&&(this.gainNode.disconnect(),this.gainNode=null)}async start(){if(!this.isRinging)if(this.audioContext||(this._initAudioContext(),this.audioContext))try{await this._resumeAudioContext(),this.isRinging=!0,this._ringPattern()}catch(e){console.warn("Could not start ringtone (may require user interaction):",e),this.isRinging=!0,this._ringPattern()}else console.warn("Web Audio API not available, cannot play ringtone")}stop(){this.isRinging&&(this.isRinging=!1,this.ringInterval&&(clearInterval(this.ringInterval),this.ringInterval=null),this._stopOscillators())}_ringPattern(){this.isRinging&&(this._startOscillators(),this.ringInterval=setTimeout(()=>{this.isRinging&&(this._stopOscillators(),this._ringPattern())},1e3))}isRinging(){return this.isRinging}get ringing(){return this.isRinging}setVolume(e){this.options.volume=Math.max(0,Math.min(1,e)),this.gainNode&&(this.gainNode.gain.value=this.options.volume)}}class _{ping(){return Promise.resolve()}beep(){return Promise.resolve()}showNotification(e,t={}){return Promise.resolve()}}class P extends _{constructor(e={}){super(),this.options={volume:void 0!==e.volume?e.volume:.2,...e},this.audioContext=null,this._initAudioContext()}_initAudioContext(){try{const e=window.AudioContext||window.webkitAudioContext;e&&(this.audioContext=new e)}catch(e){console.warn("Web Audio API not supported:",e)}}async _resumeAudioContext(){if(this.audioContext&&"suspended"===this.audioContext.state)try{await this.audioContext.resume()}catch(e){}}async _playTone(e,t,n="sine"){if(this.audioContext||(this._initAudioContext(),this.audioContext))try{await this._resumeAudioContext();const s=this.audioContext.createOscillator(),i=this.audioContext.createGain();s.type=n,s.frequency.value=e,i.gain.setValueAtTime(0,this.audioContext.currentTime),i.gain.linearRampToValueAtTime(this.options.volume,this.audioContext.currentTime+.01),i.gain.exponentialRampToValueAtTime(.01,this.audioContext.currentTime+t/1e3),s.connect(i),i.connect(this.audioContext.destination),s.start(this.audioContext.currentTime),s.stop(this.audioContext.currentTime+t/1e3)}catch(e){console.debug("Could not play notification sound:",e)}}async ping(){await this._playTone(800,50,"sine"),await new Promise(e=>setTimeout(e,30)),await this._playTone(1e3,50,"sine")}async beep(e=800,t=100){await this._playTone(e,t,"sine")}async chime(){await this._playTone(523,80,"sine"),await new Promise(e=>setTimeout(e,50)),await this._playTone(659,80,"sine"),await new Promise(e=>setTimeout(e,50)),await this._playTone(784,100,"sine")}setVolume(e){this.options.volume=Math.max(0,Math.min(1,e))}}class I{constructor(e,t,n={}){if(!t)throw new Error("CallManager is required");this.container=e,this.callManager=t,this.options={showMetrics:!1!==n.showMetrics,...n},this._setupUI(),this._setupEventListeners(),this._setupCallManagerListeners(),this._updateFromCallManager()}_setupUI(){const e=this.container.querySelector("#call-buttons-container");if(e){if(!this.container.querySelector("#call-info-container")){const t=document.createElement("div");t.id="call-info-container",e.after(t)}const t=e.querySelector("#end-call-button");if(this.container.querySelector("#call-controls-container")){const e=this.container.querySelector("#call-controls-container"),n=e.querySelector("#end-call-button");if(t&&!n){t.className="call-control-button end-call",t.style.backgroundColor="#f44336",t.style.color="white";const n=e.querySelector("#call-metrics");n?e.insertBefore(t,n):e.appendChild(t)}else if(!t&&!n){const t=document.createElement("button");t.id="end-call-button",t.className="call-control-button end-call",t.title="End call",t.textContent="End",t.style.backgroundColor="#f44336",t.style.color="white";const n=e.querySelector("#call-metrics");n?e.insertBefore(t,n):e.appendChild(t)}}else{const e=document.createElement("div");if(e.id="call-controls-container",e.innerHTML='\n          <span style="font-weight: bold; margin-right: 8px;">Call Controls:</span>\n          <button id="call-mute-mic-btn" class="call-control-button" title="Toggle microphone on/off">Mic</button>\n          <button id="call-mute-speakers-btn" class="call-control-button" title="Toggle speakers on/off">Speakers</button>\n          <button id="call-video-toggle-btn" class="call-control-button" title="Toggle camera on/off">Camera</button>\n          <span id="call-metrics"></span>\n        ',this.container.appendChild(e),t){t.className="call-control-button end-call",t.style.backgroundColor="#f44336",t.style.color="white";const n=e.querySelector("#call-metrics");n?e.insertBefore(t,n):e.appendChild(t)}else{const t=document.createElement("button");t.id="end-call-button",t.className="call-control-button end-call",t.title="End call",t.textContent="End",t.style.backgroundColor="#f44336",t.style.color="white";const n=e.querySelector("#call-metrics");n?e.insertBefore(t,n):e.appendChild(t)}}}else this.container.innerHTML='\n        <div id="call-buttons-container"></div>\n        <div id="call-info-container"></div>\n        <div id="call-controls-container">\n          <span style="font-weight: bold; margin-right: 8px;">Call Controls:</span>\n          <button id="call-mute-mic-btn" class="call-control-button" title="Toggle microphone on/off">Mic</button>\n          <button id="call-mute-speakers-btn" class="call-control-button" title="Toggle speakers on/off">Speakers</button>\n          <button id="call-video-toggle-btn" class="call-control-button" title="Toggle camera on/off">Camera</button>\n          <button id="end-call-button" class="call-control-button end-call" title="End call" style="background-color: #f44336; color: white;">End</button>\n          <span id="call-metrics"></span>\n        </div>\n      ';this.buttonsContainer=this.container.querySelector("#call-buttons-container"),this.callInfoContainer=this.container.querySelector("#call-info-container"),this.callControlsContainer=this.container.querySelector("#call-controls-container"),this.muteMicBtn=this.container.querySelector("#call-mute-mic-btn"),this.muteSpeakersBtn=this.container.querySelector("#call-mute-speakers-btn"),this.videoToggleBtn=this.container.querySelector("#call-video-toggle-btn"),this.endCallButton=this.container.querySelector("#end-call-button"),this.metricsSpan=this.container.querySelector("#call-metrics"),this.callInfoItems=new Map,this.incomingCallPrompts=new Map,this._ensureEndCallButtonInCorrectLocation()}_ensureEndCallButtonInCorrectLocation(){const e=this.container.querySelector("#call-buttons-container"),t=this.container.querySelector("#call-controls-container"),n=this.container.querySelector("#end-call-button");if(n&&t){if(e&&e.contains(n)){n.className="call-control-button end-call",n.style.backgroundColor="#f44336",n.style.color="white";const e=t.querySelector("#call-metrics");e?t.insertBefore(n,e):t.appendChild(n)}this.endCallButton=n}}_setupEventListeners(){this.muteMicBtn&&this.muteMicBtn.addEventListener("click",()=>{const e=this.callManager.getMuteState();this.callManager.setMicMuted(!e.mic)}),this.muteSpeakersBtn&&this.muteSpeakersBtn.addEventListener("click",()=>{const e=this.callManager.getMuteState();this.callManager.setSpeakersMuted(!e.speakers)}),this.videoToggleBtn&&this.videoToggleBtn.addEventListener("click",()=>{const e=this.callManager.getMuteState();this.callManager.setVideoHidden(!e.video)}),this.endCallButton&&this.endCallButton.addEventListener("click",()=>{console.log("End call button clicked from CallManagement"),this.callManager&&"function"==typeof this.callManager.endAllCalls&&this.callManager.endAllCalls()})}_setupCallManagerListeners(){this.callManager.on("mutechanged",()=>{this._updateButtonStates()}),this.callManager.on("callconnected",()=>{this._updateFromCallManager()}),this.callManager.on("callended",()=>{this._updateFromCallManager()}),this.callManager.on("metricsupdated",()=>{this._updateMetrics()})}_updateFromCallManager(){const e=this.callManager.getActiveCalls(),t=this.callManager.getPendingCalls(),n=e.audio.size>0||e.video.size>0,s=t.size>0;n||s?s&&!n?this._setStatePending():n&&this._setStateActive(e.audio,e.video):this._setStateInactive()}_setStateInactive(){this.container.classList.remove("active"),this.container.classList.remove("hidden"),this.container.style.display="flex",this.buttonsContainer&&(this.buttonsContainer.style.display="flex"),this.callControlsContainer&&(this.callControlsContainer.classList.remove("active"),this.callControlsContainer.style.display="none"),this.callInfoContainer&&(this.callInfoContainer.classList.remove("active"),this.callInfoContainer.style.display="none");for(const[e,t]of this.callInfoItems.entries())t&&t.parentNode&&t.parentNode.removeChild(t);this.callInfoItems.clear(),this.metricsSpan&&(this.metricsSpan.textContent=""),this._updateButtonStates()}_setStatePending(){this.container.classList.add("active"),this.container.classList.remove("hidden"),this.container.style.display="flex",this.callControlsContainer&&(this.callControlsContainer.classList.remove("active"),this.callControlsContainer.style.display="none"),this.callInfoContainer&&(this.callInfoContainer.classList.remove("active"),this.callInfoContainer.style.display="none");for(const[e,t]of this.callInfoItems.entries())t&&t.parentNode&&t.parentNode.removeChild(t);this.callInfoItems.clear(),this.metricsSpan&&(this.metricsSpan.textContent="")}_setStateActive(e,t){this.container.classList.add("active"),this.container.classList.remove("hidden"),this.container.style.display="flex",this.callControlsContainer&&(this.callControlsContainer.classList.add("active"),this.callControlsContainer.style.display=""),this.callInfoContainer&&(this.callInfoContainer.classList.add("active"),this.callInfoContainer.style.display=""),this._updateCallInfo(e,t),this._updateButtonStates(),this._updateMetrics()}setActiveCalls(e,t){this._updateFromCallManager()}setMuteState(e){this._updateButtonStates()}setMetrics(e,t){this._updateMetrics()}clearMetrics(e){this._updateMetrics()}clearAllMetrics(){this._updateMetrics()}showIncomingCallPrompt(e,t){console.log("CallManagement.showIncomingCallPrompt called",{peerName:e,callInfo:t,container:this.container}),this.hideIncomingCallPrompt(e),this.container&&(this.container.style.display="flex",this.container.classList.add("active"));const n=this.container?this.container.querySelector("#call-buttons-container"):null;if(console.log("buttonsContainer found:",!!n,{container:this.container,buttonsContainer:n}),!n)return console.error("call-buttons-container not found in container:",this.container),Promise.resolve(!1);const s=document.createElement("div");s.className="incoming-call-prompt",s.style.cssText="\n      padding: 12px;\n      margin: 8px 0;\n      background-color: #4CAF50;\n      color: white;\n      border-radius: 8px;\n      display: flex;\n      flex-direction: column;\n      gap: 8px;\n      align-items: center;\n      width: 100%;\n      box-sizing: border-box;\n    ";const i=t.video?"video":"audio",o=t.video?"ðŸ“¹":"ðŸ”Š",a=!0===t.video;let r,l="";l=a?'\n        <button class="accept-video-btn" style="\n          padding: 8px 16px;\n          background-color: white;\n          color: #4CAF50;\n          border: none;\n          border-radius: 4px;\n          cursor: pointer;\n          font-weight: bold;\n        ">ðŸ“¹ Answer as Video</button>\n        <button class="accept-audio-btn" style="\n          padding: 8px 16px;\n          background-color: #2196F3;\n          color: white;\n          border: none;\n          border-radius: 4px;\n          cursor: pointer;\n          font-weight: bold;\n        ">ðŸ”Š Answer as Audio</button>\n        <button class="reject-call-btn" style="\n          padding: 8px 16px;\n          background-color: #f44336;\n          color: white;\n          border: none;\n          border-radius: 4px;\n          cursor: pointer;\n          font-weight: bold;\n        ">Decline</button>\n      ':'\n        <button class="accept-call-btn" style="\n          padding: 8px 16px;\n          background-color: white;\n          color: #4CAF50;\n          border: none;\n          border-radius: 4px;\n          cursor: pointer;\n          font-weight: bold;\n        ">Accept</button>\n        <button class="reject-call-btn" style="\n          padding: 8px 16px;\n          background-color: #f44336;\n          color: white;\n          border: none;\n          border-radius: 4px;\n          cursor: pointer;\n          font-weight: bold;\n        ">Reject</button>\n      ',s.innerHTML=`\n      <div style="font-weight: bold; font-size: 1.1em;">\n        ${o} Incoming ${i} call from ${e}\n      </div>\n      <div style="display: flex; gap: 8px; flex-wrap: wrap; justify-content: center;">\n        ${l}\n      </div>\n    `;const c=new Promise(e=>{r=e});if(a){const t=s.querySelector(".accept-video-btn"),n=s.querySelector(".accept-audio-btn"),i=s.querySelector(".reject-call-btn");t.addEventListener("click",()=>{this.hideIncomingCallPrompt(e),r(!0)}),n.addEventListener("click",()=>{this.hideIncomingCallPrompt(e),r({video:!1,audio:!0})}),i.addEventListener("click",()=>{this.callManager&&this.callManager.ringer&&"function"==typeof this.callManager.ringer.stop&&this.callManager.ringer.stop(),this.hideIncomingCallPrompt(e),this.callManager&&this.callManager.endCall(e),r(!1)})}else{const t=s.querySelector(".accept-call-btn"),n=s.querySelector(".reject-call-btn");t.addEventListener("click",()=>{this.hideIncomingCallPrompt(e),r(!0)}),n.addEventListener("click",()=>{this.callManager&&this.callManager.ringer&&"function"==typeof this.callManager.ringer.stop&&this.callManager.ringer.stop(),this.hideIncomingCallPrompt(e),this.callManager&&this.callManager.endCall(e),r(!1)})}return this.incomingCallPrompts.set(e,{element:s,resolve:r}),console.log("Clearing buttonsContainer and adding prompt",{buttonsContainer:n,promptElement:s}),n.innerHTML="",n.appendChild(s),console.log("Prompt added to buttonsContainer",{buttonsContainerHTML:n.innerHTML.substring(0,100)}),c}hideIncomingCallPrompt(e){const t=this.incomingCallPrompts.get(e);if(t){const n=this.container.querySelector("#call-buttons-container");t.element&&t.element.parentNode&&t.element.parentNode.removeChild(t.element),this.incomingCallPrompts.delete(e),0===this.incomingCallPrompts.size&&n&&(n.innerHTML="")}}showMissedCallNotification(e,t){if(!this.container.querySelector("#call-buttons-container"))return;const n="incoming"===t?`Missed call from ${e}`:`${e} missed your call`,s=document.createElement("div");s.className="missed-call-notification",s.style.cssText="\n      padding: 8px 12px;\n      margin: 4px 0;\n      background-color: #ff9800;\n      color: white;\n      border-radius: 4px;\n      font-size: 0.9em;\n      text-align: center;\n    ",s.textContent=n,this.callInfoContainer&&(this.callInfoContainer.appendChild(s),setTimeout(()=>{s.parentNode&&s.parentNode.removeChild(s)},5e3))}showCallDeclinedNotification(e){if(!this.container.querySelector("#call-buttons-container"))return;const t=document.createElement("div");t.className="call-declined-notification",t.style.cssText="\n      padding: 8px 12px;\n      margin: 4px 0;\n      background-color: #f44336;\n      color: white;\n      border-radius: 4px;\n      font-size: 0.9em;\n      text-align: center;\n    ",t.textContent=`${e} declined your call`,this.callInfoContainer&&(this.callInfoContainer.appendChild(t),setTimeout(()=>{t.parentNode&&t.parentNode.removeChild(t)},5e3))}_updateCallInfo(e,t){if(this.callInfoContainer){for(const[e,t]of this.callInfoItems.entries())t&&t.parentNode&&t.parentNode.removeChild(t);this.callInfoItems.clear();for(const n of e)if(!t.has(n)){const e=document.createElement("div");e.className="call-info-item",e.textContent=`ðŸ”Š Audio call with ${n}`;const t=Array.from(this.incomingCallPrompts.values());t.length>0&&t[0].element&&t[0].element.nextSibling?this.callInfoContainer.insertBefore(e,t[0].element.nextSibling):this.callInfoContainer.appendChild(e),this.callInfoItems.set(n,e)}for(const e of t){const t=document.createElement("div");t.className="call-info-item",t.textContent=`ðŸ“¹ Video call with ${e}`;const n=Array.from(this.incomingCallPrompts.values());n.length>0&&n[0].element&&n[0].element.nextSibling?this.callInfoContainer.insertBefore(t,n[0].element.nextSibling):this.callInfoContainer.appendChild(t),this.callInfoItems.set(e,t)}}}_updateButtonStates(){const e=this.callManager.getMuteState(),t=this.callManager.getActiveCalls().video.size>0;this.muteMicBtn&&(this.muteMicBtn.textContent="Mic",this.muteMicBtn.title=e.mic?"Microphone is muted - click to unmute":"Microphone is on - click to mute",this.muteMicBtn.classList.toggle("active",e.mic),this.muteMicBtn.style.textDecoration=e.mic?"line-through":"none"),this.muteSpeakersBtn&&(this.muteSpeakersBtn.textContent="Speakers",this.muteSpeakersBtn.title=e.speakers?"Speakers are muted - click to unmute":"Speakers are on - click to mute",this.muteSpeakersBtn.classList.toggle("active",e.speakers),this.muteSpeakersBtn.style.textDecoration=e.speakers?"line-through":"none"),this.videoToggleBtn&&(this.videoToggleBtn.style.display=t?"inline-block":"none",this.videoToggleBtn.textContent="Camera",this.videoToggleBtn.title=e.video?"Camera is hidden - click to show":"Camera is on - click to hide",this.videoToggleBtn.classList.toggle("active",e.video),this.videoToggleBtn.style.textDecoration=e.video?"line-through":"none")}_updateMetrics(){if(!this.metricsSpan||!this.options.showMetrics)return;const e=this.callManager.getActiveCalls(),t=new Set([...e.audio,...e.video]),n=this.callManager.getAllMetrics();if(0===t.size)return void(this.metricsSpan.textContent="");const s=[];for(const e of t){const i=n.get(e);if(i){const n=[];if(null!==i.rtt&&void 0!==i.rtt&&n.push(`${Math.round(i.rtt)}ms`),null!==i.packetLoss&&void 0!==i.packetLoss&&i.packetLoss>0&&n.push(`Loss: ${i.packetLoss.toFixed(1)}%`),null!==i.jitter&&void 0!==i.jitter&&n.push(`Jitter: ${Math.round(i.jitter)}ms`),n.length>0){const i=t.size>1?e:"";s.push(`${i}${i?": ":""}${n.join(", ")}`)}}}s.length>0?this.metricsSpan.textContent=`ðŸ“Š ${s.join(" | ")}`:this.metricsSpan.textContent="ðŸ“Š Connecting..."}}class E{constructor(){this._userStates=new Map}setUserState(e,t){if(!e)throw new Error("User name is required");const n={status:t.status||"inactive",audio:!0===t.audio,video:!0===t.video};if(!["inactive","active","pending"].includes(n.status))throw new Error(`Invalid status: ${n.status}. Must be 'inactive', 'active', or 'pending'`);this._userStates.set(e,n)}getUserState(e){if(!e)return null;const t=this._userStates.get(e);return t?{...t}:null}getUsersByStatus(e){if(!["inactive","active","pending"].includes(e))throw new Error(`Invalid status: ${e}. Must be 'inactive', 'active', or 'pending'`);const t=[];for(const[n,s]of this._userStates.entries())s.status===e&&t.push(n);return t}getActiveCalls(){const e=new Set,t=new Set;for(const[n,s]of this._userStates.entries())"active"===s.status&&(s.audio&&e.add(n),s.video&&t.add(n));return{audio:e,video:t}}getPendingCalls(){return new Set(this.getUsersByStatus("pending"))}getActiveOrPendingCalls(){const e=new Set;for(const[t,n]of this._userStates.entries())"active"!==n.status&&"pending"!==n.status||e.add(t);return e}hasActiveCall(e){const t=this.getUserState(e);return t&&"active"===t.status}hasPendingCall(e){const t=this.getUserState(e);return t&&"pending"===t.status}removeUser(e){this._userStates.delete(e)}clear(){this._userStates.clear()}getAllStates(){return new Map(this._userStates)}}class R extends r{constructor(e,t={}){super(),this.rtcClient=e,this.options={callTimeout:t.callTimeout||15e3,statsPollInterval:t.statsPollInterval||2e3,...t},this.callUI=t.callUI||null,this.videoDisplay=t.videoDisplay||null,this.audioDisplay=t.audioDisplay||null,this.audioController=t.audioController||null,this.videoController=t.videoController||null,this.ringer=t.ringer||null,this.notifications=t.notifications||null,this.chatManager=t.chatManager||null,this.callState=new E,this.pendingCalls=new Map,this.outgoingCalls=new Map,this.groupCallMesh=new Set,this.groupCallType=null,this.muteState={mic:!1,speakers:!1,video:!1},this.statsInterval=null,this.latencyMetrics=new Map,this._handleIncomingCall=this._handleIncomingCall.bind(this),this._handleCallConnected=this._handleCallConnected.bind(this),this._handleCallEnded=this._handleCallEnded.bind(this),e&&this._setupRTCEventListeners()}_setupRTCEventListeners(){this.rtcClient.on&&(this.rtcClient.on("call",this._handleIncomingCall),this.rtcClient.on("callconnected",this._handleCallConnected),this.rtcClient.on("callended",e=>{console.log("CallManager: Received 'callended' event from RTC client for "+e),this._handleCallEnded(e)}),this.rtcClient.on("disconnectedfrompeer",e=>{this._handleDisconnectedFromUser(e)}))}_handleIncomingCall(e,t,n){console.log("CallManager._handleIncomingCall called",{peerName:e,callInfo:t,hasRinger:!!this.ringer});const s=setTimeout(()=>{this._handleCallTimeout(e,"incoming")},this.options.callTimeout);this.pendingCalls.set(e,{callInfo:t,promises:n,timeoutId:s,promptElement:null,autoAccepted:!1}),this.callState.setUserState(e,{status:"pending",audio:!1!==t.audio,video:!0===t.video});const i=this._shouldAutoAcceptIncomingCall(e,t),o=this.pendingCalls.get(e);if(o&&(o.autoAccepted=i),i?this.ringer&&"function"==typeof this.ringer.stop&&this.ringer.stop():this.ringer&&"function"==typeof this.ringer.start?(console.log("Starting ringtone..."),this.ringer.start().catch(e=>{console.error("Could not start ringtone:",e)})):console.warn("No ringer available or ringer.start is not a function",{hasRinger:!!this.ringer,ringerType:this.ringer?typeof this.ringer:"undefined",hasStart:this.ringer?typeof this.ringer.start:"N/A"}),this.emit("incomingcall",{peerName:e,callInfo:t,promises:n,timeoutId:s,autoAccepted:i}),i){console.log(`Auto-accepting incoming call from ${e} (already in group call)`);const t=this.pendingCalls.get(e);return t&&t.timeoutId&&(clearTimeout(t.timeoutId),t.timeoutId=null),Promise.resolve(!0)}return this.callUI&&"function"==typeof this.callUI.showIncomingCallPrompt?this.callUI.showIncomingCallPrompt(e,t):Promise.resolve(!0)}_shouldAutoAcceptIncomingCall(e,t){const n=this.callState.getActiveCalls(),s=n.audio.size+n.video.size;return!!(this.groupCallMesh.size>0)||s>0}_handleCallConnected(e,{localStream:t,remoteStream:n}){const s=this.pendingCalls.get(e);s&&s.timeoutId&&(clearTimeout(s.timeoutId),s.timeoutId=null),this.pendingCalls.delete(e);const i=this.outgoingCalls.get(e);i&&i.timeoutId&&clearTimeout(i.timeoutId),this.outgoingCalls.delete(e),this.ringer&&"function"==typeof this.ringer.stop&&this.ringer.stop();const o=t?.getVideoTracks().length>0||n?.getVideoTracks().length>0,a=t?.getAudioTracks().length>0||n?.getAudioTracks().length>0;this.callState.setUserState(e,{status:"active",audio:a,video:o});const r=this.callState.getActiveCalls(),l=r.audio.size+r.video.size,c=this._getActiveUsers(),d=c.length>=2,h=o?"video":"audio";this.groupCallMesh.size>0?(this.groupCallMesh.add(e),console.log(`Added ${e} to existing group call mesh. Current mesh:`,Array.from(this.groupCallMesh)),this._connectToOtherMeshParticipants(e)):(l>=2||d)&&(this.groupCallMesh.clear(),this.groupCallMesh.add(this.rtcClient.name),this.groupCallMesh.add(e),r.audio.forEach(e=>this.groupCallMesh.add(e)),r.video.forEach(e=>this.groupCallMesh.add(e)),c.forEach(e=>{e!==this.rtcClient.name&&this.groupCallMesh.add(e)}),this.groupCallType=h,console.log(`Detected group call! Initialized mesh with ${this.groupCallMesh.size} participants:`,Array.from(this.groupCallMesh)),console.log(`Active users in room: ${c.length}, Active calls: ${l}, Call type: ${h}`),this._connectToOtherMeshParticipants(null));const u=this.callState.getActiveCalls();!this.statsInterval&&(u.video.size>0||u.audio.size>0)&&this._startStatsPolling();const m=this.rtcClient?.sharedLocalStream||t;this.emit("callconnected",{sender:e,localStream:m,remoteStream:n,type:o?"video":"audio"}),o&&this.videoDisplay&&"function"==typeof this.videoDisplay.setStreams?this.videoDisplay.setStreams(e,{localStream:m,remoteStream:n}):a&&this.audioDisplay&&"function"==typeof this.audioDisplay.setStreams&&this.audioDisplay.setStreams(e,{localStream:m,remoteStream:n})}async _connectToOtherMeshParticipants(e){if(!this.groupCallType)return void console.warn("_connectToOtherMeshParticipants called but no groupCallType set");const t=this.callState.getActiveCalls(),n=new Set([...t.audio,...t.video]),s=this._getActiveUsers(),i=Array.from(this.groupCallMesh||[]),o=new Set([...s,...i]),a=Array.from(o).filter(t=>!!t&&(t!==this.rtcClient?.name&&((!e||t!==e)&&!n.has(t))));if(0===a.length)return void console.log("No other participants to connect to in mesh");console.log(`${e||"We"} joining group call. Connecting to other participants:`,a),console.log("Current active participants:",Array.from(n)),console.log("Group call mesh:",Array.from(this.groupCallMesh));const r="audio"===this.groupCallType?{video:!1,audio:!0}:{video:!0,audio:!0},l=a.map(async t=>{const s=n.has(t),i=this.pendingCalls.has(t),o=this.outgoingCalls.has(t);if(s)return console.log(`Skipping ${t} - already connected`),{participant:t,skipped:!0};if(i){console.log(`Clearing stale pending call for ${t} before reconnecting`);const e=this.pendingCalls.get(t);e?.timeoutId&&clearTimeout(e.timeoutId),this.pendingCalls.delete(t)}if(o){console.log(`Cancelling stale outgoing call for ${t} before reconnecting`);const e=this.outgoingCalls.get(t);e?.timeoutId&&clearTimeout(e.timeoutId),this.outgoingCalls.delete(t)}try{console.log(`Auto-connecting to ${t} in mesh (from ${e||"initiator"})`);const{start:n,end:s}=this.rtcClient.callUser(t,r);this.outgoingCalls.set(t,{type:this.groupCallType,cancelFn:null,timeoutId:null,isMeshConnection:!0});const i=await n;return i&&(i.localStream||i.remoteStream)&&this._handleCallConnected(t,i),{participant:t,success:!0}}catch(e){return console.warn(`Failed to auto-connect to ${t}:`,e),this.outgoingCalls.delete(t),{participant:t,success:!1,error:e}}}),c=(await Promise.allSettled(l)).filter(e=>"fulfilled"===e.status&&e.value.success).length;console.log(`Mesh connection: ${c}/${a.length} successful`)}_handleCallEnded(e){console.log("CallManager._handleCallEnded: Called for "+e+" (receiver side - only end this call)");const t=this.callState.getUserState(e);if(t&&"inactive"===t.status)return void console.log("CallManager._handleCallEnded: Call already ended for "+e+", skipping");this._finalizeCallClosure(e);const n=this.callState.getActiveCalls(),s=n.audio.size>0||n.video.size>0;console.log("CallManager._handleCallEnded: After ending "+e+", remaining calls:",{audio:Array.from(n.audio),video:Array.from(n.video),hasRemainingCalls:s}),s?console.log("CallManager._handleCallEnded: Other calls still active, keeping resources"):(this._stopStatsPolling(),this.groupCallMesh.clear(),this.groupCallType=null,console.log("CallManager._handleCallEnded: No remaining calls, released all resources"))}_handleCallTimeout(e,t){const n=this.pendingCalls.get(e),s=n?.autoAccepted;if(this.ringer&&"function"==typeof this.ringer.stop&&this.ringer.stop(),this.rtcClient&&this.rtcClient.endCallWithUser)try{this.rtcClient.endCallWithUser(e)}catch(e){console.warn("Error ending timed out call:",e)}this._finalizeCallClosure(e);const i=this.callState.getActiveCalls();i.audio.size>0||i.video.size>0||(this._stopStatsPolling(),this.groupCallMesh.clear(),this.groupCallType=null),this.emit("calltimeout",{peerName:e,direction:t}),!s&&this.callUI&&"function"==typeof this.callUI.showMissedCallNotification&&this.callUI.showMissedCallNotification(e,t),this.videoDisplay&&"function"==typeof this.videoDisplay.removeStreams&&this.videoDisplay.removeStreams(e),this.audioDisplay&&"function"==typeof this.audioDisplay.removeStreams&&this.audioDisplay.removeStreams(e)}_handleDisconnectedFromUser(e){const t=this.callState.getUserState(e),n=t&&("active"===t.status||"pending"===t.status),s=this.outgoingCalls.has(e);if(n||s){if(this.rtcClient&&this.rtcClient.endCallWithUser)try{this.rtcClient.endCallWithUser(e)}catch(e){console.warn("Error ending call with disconnected user:",e)}this._finalizeCallClosure(e);const t=this.callState.getActiveCalls();t.audio.size>0||t.video.size>0||(this._stopStatsPolling(),this.groupCallMesh.clear(),this.groupCallType=null)}}_logActiveTracksAndStreams(){console.log("=== ACTIVE TRACKS AND STREAMS (Single Source: rtcConnections) ===");const e=new Map;if(this.rtcClient&&this.rtcClient.rtcConnections)for(const[t,n]of Object.entries(this.rtcClient.rtcConnections))n&&n.localStream&&n.localStream.getTracks&&n.localStream.getTracks().forEach(n=>{e.has(n.id)||e.set(n.id,{track:n,owners:[]}),e.get(n.id).owners.push(t)});console.log(`Total unique tracks: ${e.size}`);for(const[t,{track:n,owners:s}]of e.entries())console.log(`  Track ${n.kind} ${t.substring(0,8)}... (readyState: ${n.readyState})`),console.log(`    - Used by rtcConnections: [${s.join(", ")}]`);console.log("==================================================================")}_closeStream(e,t){if(!e||"function"!=typeof e.getTracks)return void console.warn(`_closeStream: Invalid stream for ${t}`);const n=e.getTracks();console.log(`_closeStream: Closing stream for ${t} with ${n.length} track(s)`),n.forEach(e=>{let n=!1;if(this.rtcClient&&this.rtcClient.rtcConnections)for(const[s,i]of Object.entries(this.rtcClient.rtcConnections))if(s!==t&&i&&i.localStream&&i.localStream.getTracks&&i.localStream.getTracks().some(t=>t.id===e.id)){n=!0,console.log(`_closeStream: Track ${e.kind} ${e.id.substring(0,8)}... is shared with rtcConnection[${s}]`);break}if(n)console.log(`_closeStream: Keeping ${e.kind} track ${e.id.substring(0,8)}... alive (shared)`);else{console.log(`_closeStream: Stopping ${e.kind} track ${e.id.substring(0,8)}... (readyState: ${e.readyState})`);try{e.stop(),console.log(`_closeStream: Stopped track (new readyState: ${e.readyState})`)}catch(e){console.warn("_closeStream: Failed to stop track:",e)}}}),this._logActiveTracksAndStreams()}_releaseLocalStreamForUser(e){if(console.log(`_releaseLocalStreamForUser: Closing stream for ${e}`),this._logActiveTracksAndStreams(),!this.rtcClient||!this.rtcClient.rtcConnections||!this.rtcClient.rtcConnections[e])return void console.log(`_releaseLocalStreamForUser: No RTC connection for ${e}`);const t=this.rtcClient.rtcConnections[e],n=t.localStream;n?(t.localStream=null,this._closeStream(n,e)):console.log(`_releaseLocalStreamForUser: No localStream in connection for ${e}`)}_finalizeCallClosure(e){if(!e)return;const t=this.pendingCalls.get(e);t&&t.timeoutId&&clearTimeout(t.timeoutId),this.pendingCalls.delete(e);const n=this.outgoingCalls.get(e);n&&n.timeoutId&&clearTimeout(n.timeoutId),this.outgoingCalls.delete(e),this.callState.setUserState(e,{status:"inactive",audio:!1,video:!1}),this.latencyMetrics.delete(e),this.groupCallMesh.has(e)&&(this.groupCallMesh.delete(e),console.log(`Removed ${e} from group call mesh. Remaining:`,Array.from(this.groupCallMesh)),this.groupCallMesh.size<=1&&(this.groupCallMesh.clear(),this.groupCallType=null,console.log("Group call mesh cleared - no more participants"))),this.emit("callended",{peerName:e})}_releaseAllLocalStreams(){if(console.log("_releaseAllLocalStreams: Closing all RTC connection streams"),!this.rtcClient||!this.rtcClient.rtcConnections)return void console.log("_releaseAllLocalStreams: No RTC connections");const e=Object.keys(this.rtcClient.rtcConnections);console.log(`_releaseAllLocalStreams: Found ${e.length} connections`);for(const t of e)this._releaseLocalStreamForUser(t)}_getActiveUsers(){let e=[];if(this.chatManager&&"function"==typeof this.chatManager.getActiveUsers)return e=this.chatManager.getActiveUsers(),console.log("Got active users from chatManager:",e),e;if(this.rtcClient&&this.rtcClient.connectedUsers){const t=this.rtcClient.connectedUsers;return e=Array.isArray(t)?t:[],console.log("Got active users from rtcClient.connectedUsers:",e),e}return this.rtcClient&&this.rtcClient.rtcConnections?(e=Object.keys(this.rtcClient.rtcConnections).filter(e=>{const t=this.rtcClient.rtcConnections[e];return t&&t.peerConnection&&("connected"===t.peerConnection.connectionState||"completed"===t.peerConnection.connectionState)}),console.log("Got active users from rtcConnections:",e),e):(console.warn("No active users found!"),[])}async startGroupCall(e,t){if(!this.rtcClient||!this.rtcClient.callUser)throw new Error("RTC client not available or does not support callUser");let n;if("all"===e?(n=this._getActiveUsers(),console.log('startGroupCall: Got active users for "all":',n)):Array.isArray(e)?(n=e,console.log("startGroupCall: Using provided user array:",n)):(n=[e],console.log("startGroupCall: Single user converted to array:",n)),0===n.length)throw console.error("startGroupCall: No users to call!"),new Error("No users to call");console.log(`startGroupCall: Will call ${n.length} users:`,n);const s=this.callState.getActiveCalls(),i=this.callState.getPendingCalls(),o=new Set([...s.audio,...s.video,...i,...this.outgoingCalls.keys()]);if(n=n.filter(e=>!o.has(e)),0===n.length)throw new Error("All selected users are already in a call");this.groupCallMesh.clear(),this.groupCallMesh.add(this.rtcClient.name),n.forEach(e=>this.groupCallMesh.add(e)),this.groupCallType=t,console.log(`Starting group ${t} call mesh with ${n.length} users:`,n),console.log("Group call mesh participants:",Array.from(this.groupCallMesh));const a="audio"===t?{video:!1,audio:!0}:{video:!0,audio:!0};console.log(`Calling ${n.length} users simultaneously:`,n);const r=n.map(async e=>{try{console.log(`Initiating call to ${e}...`);const n=setTimeout(()=>{this._handleCallTimeout(e,"outgoing")},this.options.callTimeout);this.outgoingCalls.set(e,{type:t,cancelFn:null,timeoutId:n,isMeshConnection:!1});const{start:s,end:i}=this.rtcClient.callUser(e,a),o=await s;return n&&clearTimeout(n),o&&(o.localStream||o.remoteStream)&&this._handleCallConnected(e,o),this.emit("callstarted",{user:e,type:t}),console.log(`Successfully called ${e}`),{user:e,success:!0,result:{...o,end:i}}}catch(t){console.error(`Failed to call ${e}:`,t);const n=this.outgoingCalls.get(e);return n&&n.timeoutId&&clearTimeout(n.timeoutId),this.outgoingCalls.delete(e),this.groupCallMesh.delete(e),"Call rejected"===t||"Call rejected"===t?.message?(this._handleCallEnded(e),this.emit("callrejected",{user:e})):(this._handleCallEnded(e),this.emit("callerror",{user:e,error:t})),{user:e,success:!1,error:t}}}),l=await Promise.allSettled(r),c=[],d=[];return l.forEach((e,t)=>{"fulfilled"===e.status&&e.value.success?c.push(e.value.user):(d.push({user:n[t],error:"fulfilled"===e.status?e.value.error:e.reason}),this.groupCallMesh.delete(n[t]))}),this.emit("groupcallstarted",{users:n,type:t,successful:c,failed:d,results:l}),{successful:c,failed:d,total:n.length}}async startCall(e,t){if(!this.rtcClient||!this.rtcClient.callUser)throw new Error("RTC client not available or does not support callUser");const n="audio"===t?{video:!1,audio:!0}:{video:!0,audio:!0};let s=null;s=setTimeout(()=>{this._handleCallTimeout(e,"outgoing")},this.options.callTimeout),this.outgoingCalls.set(e,{type:t,cancelFn:(t="cancelled")=>{if(s&&(clearTimeout(s),s=null),this.outgoingCalls.delete(e),this.rtcClient&&this.rtcClient.endCallWithUser)try{this.rtcClient.endCallWithUser(e)}catch(e){console.error("Error canceling call:",e)}this.emit("callcancelled",{user:e,reason:t})},timeoutId:s});try{const{start:i,end:o}=this.rtcClient.callUser(e,n),a=await i;return s&&(clearTimeout(s),s=null),a&&(a.localStream||a.remoteStream)&&this._handleCallConnected(e,a),this.emit("callstarted",{user:e,type:t}),{...a,end:o}}catch(t){throw s&&clearTimeout(s),this.outgoingCalls.delete(e),"Call rejected"===t||"Call rejected"===t?.message?(this._handleCallEnded(e),this.emit("callrejected",{user:e})):(this._handleCallEnded(e),this.emit("callerror",{user:e,error:t})),t}}endCall(e){if(console.log("CallManager.endCall: Ending call with "+e),this.rtcClient&&this.rtcClient.endCallWithUser)try{this.rtcClient.endCallWithUser(e)}catch(e){console.error("Error ending call:",e)}this._finalizeCallClosure(e);const t=this.callState.getActiveCalls();t.audio.size>0||t.video.size>0?console.log("CallManager.endCall: Other calls still active, keeping resources"):(this._stopStatsPolling(),this.groupCallMesh.clear(),this.groupCallType=null,console.log("CallManager.endCall: No remaining calls, released all resources"))}endAllCalls(){console.log("CallManager.endAllCalls: Ending ALL calls");const e=this.callState.getActiveCalls(),t=this.callState.getPendingCalls(),n=new Set([...e.video,...e.audio,...t,...this.outgoingCalls.keys()]);if(this.rtcClient&&this.rtcClient.rtcConnections)for(const e of Object.keys(this.rtcClient.rtcConnections))n.add(e);console.log("CallManager.endAllCalls: All users to end:",Array.from(n));for(const e of n)this.endCall(e);console.log("CallManager.endAllCalls: Complete")}setMicMuted(e){this.muteState.mic=e;for(const[t,n]of this.localStreams.entries())if(n&&n instanceof MediaStream){n.getAudioTracks().forEach(t=>{t.enabled=!e})}this.emit("mutechanged",{...this.muteState})}setSpeakersMuted(e){this.muteState.speakers=e,this.emit("mutechanged",{...this.muteState}),this.emit("speakersmutechanged",{muted:e})}setVideoHidden(e){this.muteState.video=e;for(const[t,n]of this.localStreams.entries())if(n&&n instanceof MediaStream){n.getVideoTracks().forEach(t=>{t.enabled=!e})}this.videoController&&"function"==typeof this.videoController.setVideoHidden&&this.videoController.setVideoHidden(e,this.localStreams),this.emit("mutechanged",{...this.muteState})}getMuteState(){return{...this.muteState}}getActiveCalls(){return this.callState.getActiveCalls()}getPendingCalls(){return this.callState.getPendingCalls()}getUserCallState(e){return this.callState.getUserState(e)}getAllCallStates(){return this.callState.getAllStates()}getMetrics(e){return this.latencyMetrics.get(e)||null}getAllMetrics(){return new Map(this.latencyMetrics)}_startStatsPolling(){this.statsInterval||(this.statsInterval=setInterval(()=>{this._collectConnectionStats()},this.options.statsPollInterval),this._collectConnectionStats())}_stopStatsPolling(){this.statsInterval&&(clearInterval(this.statsInterval),this.statsInterval=null)}async _collectConnectionStats(){if(!this.rtcClient||!this.rtcClient.rtcConnections)return;const e=this.callState.getActiveCalls(),t=new Set([...e.video,...e.audio]);for(const e of t){const t=this.rtcClient.rtcConnections[e];if(t)try{const n=t.streamConnection;if(n&&("connected"===n.iceConnectionState||"completed"===n.iceConnectionState)){const t=await n.getStats();let s=null,i=null,o=null;for(const[e,n]of t.entries()){if("candidate-pair"===n.type&&"succeeded"===n.state&&(void 0!==n.currentRoundTripTime&&n.currentRoundTripTime>0?s=1e3*n.currentRoundTripTime:void 0!==n.roundTripTime&&n.roundTripTime>0&&(s=1e3*n.roundTripTime)),"transport"===n.type&&(void 0!==n.currentRoundTripTime&&n.currentRoundTripTime>0?s=1e3*n.currentRoundTripTime:void 0!==n.rtt&&n.rtt>0&&(s=1e3*n.rtt)),"inbound-rtp"===n.type&&"audio"===n.mediaType){if(void 0!==n.packetsLost&&void 0!==n.packetsReceived){const e=n.packetsLost+n.packetsReceived;e>0&&(i=n.packetsLost/e*100)}void 0!==n.jitter&&n.jitter>0&&(o=1e3*n.jitter)}if("inbound-rtp"===n.type&&"video"===n.mediaType&&void 0!==n.packetsLost&&void 0!==n.packetsReceived){const e=n.packetsLost+n.packetsReceived;if(e>0){const t=n.packetsLost/e*100;null===i&&(i=t)}}}const a=this.latencyMetrics.get(e)||{rtt:null,packetLoss:null,jitter:null},r={rtt:null!==s?s:a.rtt,packetLoss:null!==i?i:a.packetLoss,jitter:null!==o?o:a.jitter};this.latencyMetrics.set(e,r),this.emit("metricsupdated",{user:e,metrics:r})}}catch(t){console.warn(`Error collecting stats for ${e}:`,t)}}}destroy(){this._stopStatsPolling(),this.endAllCalls(),this.pendingCalls.clear(),this.outgoingCalls.clear(),this.latencyMetrics.clear(),this.callState.clear(),this.rtcClient&&this.rtcClient.off&&(this.rtcClient.off("call",this._handleIncomingCall),this.rtcClient.off("callconnected",this._handleCallConnected),this.rtcClient.off("callended",this._handleCallEnded)),this.removeAllListeners()}}class U extends r{constructor(e,t={}){super(),this.rtcClient=e,this.options={primaryUserColor:t.primaryUserColor||"lightblue",userColors:t.userColors||["lightcoral","lightseagreen","lightsalmon","lightgreen"],...t},this.chatUI=t.chatUI||null,this.notifications=t.notifications||null,this.history=[],this.activeUsers=[],this.userColors=[...this.options.userColors],this.name=t.name||"?",this._handleChatMessage=this._handleChatMessage.bind(this),this._handleUserConnected=this._handleUserConnected.bind(this),this._handleUserDisconnected=this._handleUserDisconnected.bind(this),e&&(this._setupRTCEventListeners(),this._hydrateActiveUsersFromClient())}_setupRTCEventListeners(){if(this.rtcClient.on){this.rtcClient.on("chat",this._handleChatMessage);const e=this.rtcClient&&Array.isArray(this.rtcClient.validatedPeers);this.rtcClient.on("validation",(e,t)=>{console.log("ChatManager: Received validation event for",e,"trusted:",t),this.activeUsers.includes(e)?console.log("ChatManager: User",e,"already in activeUsers"):(console.log("ChatManager: Adding validated user",e),this._handleUserConnected(e))}),this.rtcClient.on("connectedtopeer",t=>{e?console.log("ChatManager: Received connectedtopeer for",t,"(waiting for validation)"):(console.log("ChatManager: Adding user on connectedtopeer (non-signed client)",t),this._handleUserConnected(t))}),this.rtcClient.on("disconnectedfrompeer",this._handleUserDisconnected)}}_hydrateActiveUsersFromClient(){if(this.rtcClient)if(Array.isArray(this.rtcClient.validatedPeers))this.rtcClient.validatedPeers.forEach(e=>{e&&!this.activeUsers.includes(e)&&(console.log("ChatManager: Hydrating validated peer",e),this._handleUserConnected(e))});else{let e=null;"function"==typeof this.rtcClient.connectedUsers?e=this.rtcClient.connectedUsers():Array.isArray(this.rtcClient.connectedUsers)&&(e=this.rtcClient.connectedUsers),Array.isArray(e)&&e.length&&e.forEach(e=>{e&&!this.activeUsers.includes(e)&&(console.log("ChatManager: Hydrating connected peer",e),this._handleUserConnected(e))})}}_handleChatMessage(e,t){const n={data:e,sender:t,timestamp:Date.now()};this.history.push(n),this.emit("message",n)}_handleUserConnected(e){this.activeUsers.includes(e)||(this.activeUsers.push(e),this.emit("userconnected",{user:e}),this.notifications&&"function"==typeof this.notifications.ping&&this.notifications.ping().catch(e=>{console.debug("Could not play connection ping:",e)}),this.chatUI&&"function"==typeof this.chatUI.updateActiveUsers&&this.chatUI.updateActiveUsers([...this.activeUsers]))}_handleUserDisconnected(e){const t=this.activeUsers.indexOf(e);if(-1!==t){const n=this.userColors[t%this.userColors.length];this.activeUsers.splice(t,1),this.userColors=this.userColors.filter(e=>e!==n).concat([n]),this.emit("userdisconnected",{user:e}),this.chatUI&&"function"==typeof this.chatUI.updateActiveUsers&&this.chatUI.updateActiveUsers([...this.activeUsers])}}sendMessage(e){if(!e&&this.chatUI&&"function"==typeof this.chatUI.getMessageInput&&(e=this.chatUI.getMessageInput()),!e)throw new Error("Message is required");if(!this.rtcClient)throw new Error("RTC client not available");if(!this.rtcClient.sendRTCChat)throw new Error("RTC client does not support sendRTCChat");this.rtcClient.sendRTCChat(e),this.chatUI&&"function"==typeof this.chatUI.clearMessageInput&&this.chatUI.clearMessageInput()}getUserColor(e){if(e===this.name+"( You )")return this.options.primaryUserColor;const t=this.activeUsers.indexOf(e);return-1!==t?this.userColors[t%this.userColors.length]:this.options.primaryUserColor}getHistory(){return[...this.history]}setHistory(e){this.history=[...e],this.emit("historyupdated",{history:this.history})}getActiveUsers(){return[...this.activeUsers]}setName(e){this.name=e,this.emit("namechanged",{name:e})}getName(){return this.name}destroy(){this.history=[],this.activeUsers=[],this.userColors=[...this.options.userColors],this.rtcClient&&this.rtcClient.off&&(this.rtcClient.off("chat",this._handleChatMessage),this.rtcClient.off("connectedtopeer",this._handleUserConnected),this.rtcClient.off("disconnectedfrompeer",this._handleUserDisconnected)),this.removeAllListeners()}}class A{static getDefaultConfig(){return{allowRoomChange:!0,showRoom:!0,baseTopic:"",currentRoom:"",callModes:"both",callTimeout:15e3,videoDisplayComponent:null,primaryUserColor:"lightblue",userColors:["lightcoral","lightseagreen","lightsalmon","lightgreen"],ringerVolume:.3,notificationVolume:.2}}static validateConfig(e={}){const t={...this.getDefaultConfig()};return"boolean"==typeof e.allowRoomChange&&(t.allowRoomChange=e.allowRoomChange),"boolean"==typeof e.showRoom&&(t.showRoom=e.showRoom),"string"==typeof e.baseTopic&&(t.baseTopic=e.baseTopic),"string"==typeof e.currentRoom&&(t.currentRoom=e.currentRoom),["audio","video","both"].includes(e.callModes)&&(t.callModes=e.callModes),"number"==typeof e.callTimeout&&e.callTimeout>0&&(t.callTimeout=e.callTimeout),void 0!==e.videoDisplayComponent&&(t.videoDisplayComponent=e.videoDisplayComponent),"string"==typeof e.primaryUserColor&&(t.primaryUserColor=e.primaryUserColor),Array.isArray(e.userColors)&&(t.userColors=e.userColors),"number"==typeof e.ringerVolume&&e.ringerVolume>=0&&e.ringerVolume<=1&&(t.ringerVolume=e.ringerVolume),"number"==typeof e.notificationVolume&&e.notificationVolume>=0&&e.notificationVolume<=1&&(t.notificationVolume=e.notificationVolume),t}}class L extends r{constructor(e={}){super(),this._state={...e}}get(e){return this._state[e]}set(e,t){const n=this._state[e];n!==t&&(this._state[e]=t,this.emit("change",{key:e,value:t,oldValue:n}),this.emit(`change:${e}`,{value:t,oldValue:n}))}getAll(){return{...this._state}}setMultiple(e){Object.keys(e).forEach(t=>{this.set(t,e[t])})}reset(e=null){this._state=e?{...e}:{},this.emit("reset",{state:this.getAll()})}}class D extends HTMLElement{constructor(e={}){super(),this.config={...e},this._initShadowDOM(),this._initialized=!1}_initShadowDOM(){this.attachShadow({mode:"open"})}connectedCallback(){this._initialized||(this._initialize(),this._initialized=!0)}disconnectedCallback(){}_initialize(){}getConfig(e,t=void 0){return void 0!==this.config[e]?this.config[e]:t}setConfig(e,t){this.config[e]=t}dispatchCustomEvent(e,t={},n=!0,s=!0){this.dispatchEvent(new CustomEvent(e,{detail:t,bubbles:n,composed:s}))}getRoot(){return this.shadowRoot||this}queryRoot(e){const t=this.getRoot();return t.querySelector?t.querySelector(e):null}queryRootAll(e){const t=this.getRoot();return t.querySelectorAll?t.querySelectorAll(e):[]}}class N extends D{constructor(e={}){super({allowRoomChange:!1!==e.allowRoomChange,showRoom:!1!==e.showRoom,baseTopic:e.baseTopic||"",currentRoom:e.currentRoom||"",primaryUserColor:e.primaryUserColor||"lightblue",...e}),this.shadowRoot.innerHTML=`\n      <style>\n        :host {\n          --primary-user-color: ${this.config.primaryUserColor};\n        }\n        .chat-header {\n          cursor: pointer;\n          background-color: var(--primary-user-color);\n          padding: 10px;\n          font-weight: bold;\n          border-top-left-radius: 10px;\n          display: flex;\n          flex-direction: column;\n          gap: 5px;\n        }\n        .room-display {\n          display: flex;\n          align-items: center;\n          gap: 2px;\n        }\n        .room-display > span:first-child {\n          margin-right: 5px;\n        }\n        .room-display.hidden {\n          display: none;\n        }\n        .chat-room-box {\n          display: none;\n        }\n        .chat-room-box.hidden {\n          display: none;\n        }\n        .rounded {\n          border-radius: 5px;\n        }\n        input.rounded {\n          border: 1px solid #333;\n          padding: 2px 5px;\n        }\n        #room-name {\n          font-weight: normal;\n          padding: 2px 5px;\n          border-radius: 3px;\n          width: 160px;\n          border: 1px solid #333;\n          background-color: white;\n        }\n        #chat-room {\n          width: 200px;\n        }\n        #chat-name {\n          width: 200px;\n        }\n      </style>\n      <div class="chat-header">\n        <div class="room-display">\n          <span>Room:</span>\n          <span id="room-prefix"></span>\n          <input id="room-name" type="text" class="rounded">\n        </div>\n        <div id="chat-room-box" class="chat-room-box hidden">\n          room: <input id="chat-room" class="rounded">\n        </div>\n        <div>\n          Your name: <input id="chat-name" class="rounded">\n        </div>\n      </div>\n    `,this._cacheElements(),this._setupEventListeners()}_initialize(){this.roomDisplay&&(this.getConfig("showRoom")?this.roomDisplay.classList.remove("hidden"):this.roomDisplay.classList.add("hidden")),this.roomName&&(this.roomName.value=this.getConfig("currentRoom")||""),this.roomPrefix&&(this.roomPrefix.textContent=this.getConfig("baseTopic")||"")}_cacheElements(){this.roomDisplay=this.queryRoot(".room-display"),this.roomPrefix=this.queryRoot("#room-prefix"),this.roomName=this.queryRoot("#room-name"),this.chatRoomBox=this.queryRoot("#chat-room-box"),this.chatRoom=this.queryRoot("#chat-room"),this.chatName=this.queryRoot("#chat-name")}_setupEventListeners(){const e=this.queryRoot(".chat-header");if(e&&e.addEventListener("click",e=>{this.dispatchCustomEvent("togglecollapse")}),this.roomName){this.getConfig("allowRoomChange")?(this.roomName.addEventListener("blur",()=>this._onRoomChange()),this.roomName.addEventListener("keydown",e=>{"Enter"===e.key?this._onRoomChange():"Escape"===e.key&&this._cancelRoomEdit()})):this.roomName.readOnly=!0;const e=e=>e.stopPropagation();this.roomName.addEventListener("click",e),this.roomName.addEventListener("mousedown",e)}if(this.chatName){this.chatName.addEventListener("change",()=>this._onNameChange());const e=e=>e.stopPropagation();this.chatName.addEventListener("click",e),this.chatName.addEventListener("mousedown",e)}const t=e=>e.stopPropagation();this.roomDisplay&&(this.roomDisplay.addEventListener("click",t),this.roomDisplay.addEventListener("mousedown",t))}_initialize(){this.roomDisplay&&(this.config.showRoom?this.roomDisplay.classList.remove("hidden"):this.roomDisplay.classList.add("hidden")),this.roomName&&(this.roomName.value=this.config.currentRoom||""),this.roomPrefix&&(this.roomPrefix.textContent=this.config.baseTopic||"")}_onRoomChange(){const e=this.roomName.value.trim();this.dispatchCustomEvent("roomchange",{room:e})}_cancelRoomEdit(){this.roomName&&(this.roomName.value=this.getConfig("currentRoom")||"")}_onNameChange(){const e=this.chatName.value.trim();this.dispatchCustomEvent("namechange",{name:e})}setRoom(e){this.roomName&&(this.roomName.value=e),this.setConfig("currentRoom",e)}setName(e){this.chatName&&(this.chatName.value=e)}setRoomPrefix(e){this.roomPrefix&&(this.roomPrefix.textContent=e),this.setConfig("baseTopic",e)}setCollapsible(e){const t=this.queryRoot(".chat-header");t&&(t.style.cursor=e?"pointer":"default")}}customElements.get("chat-header")||customElements.define("chat-header",N);class B extends D{constructor(e={}){super(e),this.userColorMap=new Map}updateUsers(e,t=null){throw new Error("updateUsers must be implemented by subclass")}getUserColor(e){if(this.userColorMap||(this.userColorMap=new Map),!this.userColorMap.has(e)){const t=this.userColorMap.size,n=this.getConfig("userColors")||[],s=n[t%n.length];this.userColorMap.set(e,s)}return this.userColorMap.get(e)}setUserColor(e,t){this.userColorMap||(this.userColorMap=new Map),this.userColorMap.set(e,t)}clear(){throw new Error("clear must be implemented by subclass")}_onUserClick(e){this.dispatchCustomEvent("userclick",{user:e})}}class q extends B{constructor(e={}){super({userColors:e.userColors||["lightcoral","lightseagreen","lightsalmon","lightgreen"],...e}),this.shadowRoot.innerHTML='\n      <style>\n        .active-users {\n          padding: 0px 0px 0px 0px;\n          margin: 0px 0px 8px 0px;\n          display: flex;\n          flex-wrap: wrap;\n          align-items: center;\n        }\n        .user-bubble {\n          display: inline-block;\n          padding: 4px 4px;\n          border-radius: 12px;\n          font-size: 0.85em;\n          cursor: pointer;\n          color: #333;\n          font-weight: 500;\n          margin: 0;\n          margin-block-start: 0;\n          margin-block-end: 0;\n          margin-inline-start: 0;\n          margin-inline-end: 0;\n        }\n        .user-bubble:hover {\n          opacity: 0.8;\n        }\n        .waiting-message {\n          color: #666;\n          font-size: 0.9em;\n          font-style: italic;\n          padding: 8px;\n        }\n      </style>\n      <div class="active-users">\n        <div class="waiting-message">Waiting for others to join...</div>\n      </div>\n    ',this.activeUsersEl=this.queryRoot(".active-users")}_initialize(){}updateUsers(e,t=null){if(this.activeUsersEl){if(this.activeUsersEl.innerHTML="",0===e.length){const e=document.createElement("div");return e.className="waiting-message",e.textContent="Waiting for others to join...",void this.activeUsersEl.appendChild(e)}e.forEach(n=>{const s=document.createElement("p");let i;if(s.className="user-bubble",t)i=t(n);else{const t=e.indexOf(n),s=this.getConfig("userColors")||[];i=s[t%s.length]}s.style.backgroundColor=i,s.textContent=n,s.title=n,s.addEventListener("click",()=>{this._onUserClick(n)}),this.activeUsersEl.appendChild(s)})}}clear(){if(this.activeUsersEl){this.activeUsersEl.innerHTML="";const e=document.createElement("div");e.className="waiting-message",e.textContent="Waiting for others to join...",this.activeUsersEl.appendChild(e)}}}customElements.get("active-users-list")||customElements.define("active-users-list",q);class V extends D{constructor(e={}){super({primaryUserColor:e.primaryUserColor||"lightblue",userColors:e.userColors||["lightcoral","lightseagreen","lightsalmon","lightgreen"],...e}),this.shadowRoot.innerHTML='\n      <style>\n        .messages {\n          max-height: 400px;\n          overflow-y: auto;\n          padding: 5px;\n          margin-bottom: 8px;\n          display: flex;\n          flex-direction: column;\n          gap: 6px;\n        }\n        .message {\n          padding: 4px 8px;\n          border-radius: 8px;\n          max-width: 80%;\n          word-wrap: break-word;\n          position: relative;\n          font-size: 0.85em;\n        }\n        .message.own-message {\n          align-self: flex-end;\n          color: #333;\n        }\n        .message.other-message {\n          align-self: flex-start;\n          color: #333;\n        }\n        .message.custom {\n          align-self: stretch;\n          max-width: 100%;\n        }\n      </style>\n      <div class="messages"></div>\n    ',this.messagesEl=this.queryRoot(".messages"),this.userColorMap=new Map}_initialize(){}appendMessage(e){if(!this.messagesEl)return;const{data:t,sender:n,timestamp:s,isOwn:i}=e;if(t instanceof HTMLElement){const e=document.createElement("div");return e.className="message custom",e.appendChild(t),this.messagesEl.appendChild(e),void this._scrollToBottom()}const o=document.createElement("div");if(o.className="message",o.textContent=t,i||n&&n.includes("( You )"))o.classList.add("own-message"),o.style.backgroundColor=this.getConfig("primaryUserColor");else{o.classList.add("other-message");const e=this.getUserColor(n);o.style.backgroundColor=e}s&&(o.title=new Date(s).toLocaleString()),this.messagesEl.appendChild(o),this._scrollToBottom()}displayMessage(e){this.appendMessage(e)}getUserColor(e){if(!e)return this.getConfig("userColors")[0];if(!this.userColorMap.has(e)){const t=this.userColorMap.size,n=this.getConfig("userColors"),s=n[t%n.length];this.userColorMap.set(e,s)}return this.userColorMap.get(e)}setUserColor(e,t){this.userColorMap.set(e,t)}clear(){this.messagesEl&&(this.messagesEl.innerHTML="")}loadHistory(e){Array.isArray(e)&&e.forEach(e=>{this.appendMessage(e)})}setCurrentUserName(e){this.currentUserName=e}_scrollToBottom(){this.messagesEl&&(this.messagesEl.scrollTop=this.messagesEl.scrollHeight)}}customElements.get("messages-component")||customElements.define("messages-component",V);class H extends D{constructor(e={}){super({callModes:e.callModes||"both",...e}),this.shadowRoot.innerHTML='\n      <style>\n        .input-container {\n          display: flex;\n          align-items: center;\n          gap: 5px;\n          padding: 8px;\n          border-top: 1px solid #ddd;\n          background-color: #f9f9f9;\n        }\n        #input-message {\n          flex: 1;\n          padding: 6px 10px;\n          border: 1px solid #ccc;\n          border-radius: 4px;\n          font-size: 0.9em;\n        }\n        #input-message:disabled {\n          background-color: #e0e0e0;\n          cursor: not-allowed;\n        }\n        button {\n          padding: 6px 12px;\n          border: 1px solid #ccc;\n          border-radius: 4px;\n          cursor: pointer;\n          background-color: white;\n          font-size: 0.9em;\n        }\n        button:hover {\n          background-color: #f0f0f0;\n        }\n        button:disabled {\n          opacity: 0.5;\n          cursor: not-allowed;\n        }\n      </style>\n      <div class="input-container">\n        <input id="input-message" type="text" placeholder="Type a message...">\n        <button id="emoji-button">ðŸ‘‹</button>\n        <button id="clear-button" title="Clear chat view (only clears your side, doesn\'t delete messages)">ðŸ—‘ï¸</button>\n      </div>\n    ',this._cacheElements(),this._setupEventListeners()}_cacheElements(){this.inputContainer=this.queryRoot(".input-container"),this.inputMessage=this.queryRoot("#input-message"),this.emojiButton=this.queryRoot("#emoji-button"),this.clearButton=this.queryRoot("#clear-button")}_initialize(){}_setupEventListeners(){this.inputMessage&&this.inputMessage.addEventListener("keydown",e=>{"Enter"!==e.key||e.ctrlKey||(e.preventDefault(),this._onSend()),e.stopPropagation()}),this.emojiButton&&this.emojiButton.addEventListener("click",()=>{this.dispatchCustomEvent("emojiclick")}),this.clearButton&&this.clearButton.addEventListener("click",()=>{this.dispatchCustomEvent("clearclick")})}_onSend(){const e=this.inputMessage.value.trim();e&&(this.dispatchCustomEvent("sendmessage",{message:e}),this.clear())}getValue(){return this.inputMessage?this.inputMessage.value:""}clear(){this.inputMessage&&(this.inputMessage.value="")}setEnabled(e){this.inputMessage&&(this.inputMessage.disabled=!e,this.inputMessage.placeholder=e?"Type a message...":"Waiting for others to join..."),this.emojiButton&&(this.emojiButton.disabled=!e),this.clearButton&&(this.clearButton.disabled=!e)}}customElements.get("message-input")||customElements.define("message-input",H);class j extends HTMLElement{constructor(e={}){super(),this.config=A.validateConfig(e),this.state=new L({currentRoom:this.config.currentRoom,baseTopic:this.config.baseTopic,name:"?"}),this._rtc=null,this._storage=null,this.attachShadow({mode:"open"}),this.shadowRoot.innerHTML=`\n      <style id="chat-box-styles">\n        ${this._getFullCSS()}\n      </style>\n      <div id="chat-container">\n        <chat-header id="chat-header-component"></chat-header>\n        <div id="call-management">\n          <div id="call-buttons-container">\n            <button id="audio-call-button" class="call-button audio-call" title="Start audio call">Start Audio Call</button>\n            <button id="video-call-button" class="call-button video-call" title="Start video call">Start Video Call</button>\n          </div>\n          <div id="call-info-container"></div>\n          <div id="call-controls-container">\n            <span id="call-controls-label">Call Controls:</span>\n            <button id="call-mute-mic-btn" class="call-control-button" title="Toggle microphone on/off">Mic</button>\n            <button id="call-mute-speakers-btn" class="call-control-button" title="Toggle speakers on/off">Speakers</button>\n            <button id="call-video-toggle-btn" class="call-control-button" title="Toggle camera on/off">Camera</button>\n            <button id="end-call-button" class="call-control-button end-call" title="End call" style="background-color: #f44336; color: white;">End</button>\n            <span id="call-metrics"></span>\n          </div>\n        </div>\n        <div id="chat-video"></div>\n        <div id="chat-audio"></div>\n        <div id="chat-body">\n          <active-users-list id="active-users-component"></active-users-list>\n          <messages-component id="messages-component"></messages-component>\n          <message-input id="message-input-component"></message-input>\n        </div>\n      </div>\n    `,this._cacheElements(),this._initializeComponents(),this._setupEventListeners(),this._initializeUI(),this._updateCallButtonVisibility()}connectedCallback(){this.style.setProperty("--primary-user-color",this.config.primaryUserColor),super.connectedCallback&&super.connectedCallback()}async _loadStyles(){try{const e=new URL("./chat-box.css",import.meta.url).href,t=await fetch(e);if(!t.ok)throw new Error("CSS file not found");{const e=await t.text(),n=this.shadowRoot.getElementById("chat-box-styles");if(n)n.textContent=e;else{const t=document.createElement("style");t.textContent=e,this.shadowRoot.insertBefore(t,this.shadowRoot.firstChild)}}}catch(e){console.warn("Could not load chat-box.css, using inline styles fallback:",e);const t=this.shadowRoot.getElementById("chat-box-styles");t&&(t.textContent=this._getInlineStylesFallback())}}_getFullCSS(){return`\n      :host {\n        --primary-user-color: ${this.config.primaryUserColor};\n        --user-colors: lightcoral, lightseagreen, lightsalmon, lightgreen;\n      }\n      .rounded { border-radius: 5px; }\n      .hidden { display: none !important; }\n      .visible { display: block !important; }\n        #chat-container {\n          position: fixed;\n          bottom: 0.5em;\n          right: 0.5em;\n          border: 1px solid #ccc;\n          background-color: #f9f9f9;\n          border-radius: 10px;\n          min-width: 350px;\n          z-index: 9999;\n        }\n        #chat-header {\n          cursor: pointer;\n        background-color: var(--primary-user-color);\n          padding: 10px;\n          font-weight: bold;\n          border-top-left-radius: 10px;\n          display: flex;\n          flex-direction: column;\n          gap: 5px;\n        }\n      #call-management {\n        display: flex;\n        background-color: #f5f5f5;\n        border-top: 2px solid #ddd;\n        border-bottom: 2px solid #ddd;\n        padding: 10px;\n        flex-direction: column;\n        gap: 8px;\n      }\n      #call-management.hidden { display: none; }\n      #call-buttons-container {\n        display: flex;\n        align-items: center;\n        gap: 8px;\n        flex-wrap: wrap;\n      }\n      .call-button {\n        padding: 6px 12px;\n        border: 1px solid #ccc;\n        border-radius: 4px;\n        cursor: pointer;\n        font-size: 0.9em;\n        display: none;\n        background-color: white;\n      }\n      .call-button.visible {\n        display: inline-block;\n      }\n      .call-button.audio-call,\n      .call-button.video-call {\n        color: green;\n      }\n      .call-button.end-call,\n      .call-button.cancel {\n        color: red;\n      }\n      .call-button:hover {\n        background-color: #f0f0f0;\n      }\n      #call-controls-container {\n        display: none;\n        align-items: center;\n        gap: 8px;\n        flex-wrap: wrap;\n      }\n      #call-controls-container.active {\n        display: flex;\n      }\n      #call-info-container {\n        display: none;\n      }\n      #call-info-container.active {\n        display: flex;\n      }\n      #call-controls-label {\n        font-weight: bold;\n        margin-right: 8px;\n      }\n      #call-info-container {\n        display: flex;\n        flex-direction: column;\n        gap: 5px;\n      }\n      .call-info-item {\n        font-size: 0.85em;\n        padding: 5px 8px;\n        border-radius: 4px;\n        background-color: #e8f5e9;\n        border-left: 3px solid #4caf50;\n      }\n      .call-control-button {\n        padding: 6px 12px;\n        border: 1px solid #ccc;\n        border-radius: 4px;\n        cursor: pointer;\n        background-color: white;\n        color: orange;\n        font-size: 0.9em;\n      }\n      .call-control-button:hover { background-color: #f0f0f0; }\n      .call-control-button.active {\n        background-color: #ff6b6b;\n        color: white;\n      }\n      .call-control-button.hidden { display: none; }\n      #call-metrics {\n        margin-left: auto;\n        font-size: 0.85em;\n        color: #666;\n      }\n        #room-display {\n          display: flex;\n          align-items: center;\n          gap: 2px;\n        }\n      #room-display > span:first-child { margin-right: 5px; }\n      #room-display.hidden { display: none; }\n        #room-prefix {\n          color: gray;\n          font-weight: normal;\n        }\n      #chat-header > div:last-child { margin-left: 5px; }\n        #room-name {\n          font-weight: normal;\n          padding: 2px 5px;\n          border-radius: 3px;\n          width: 160px;\n          border: 1px solid #333;\n          background-color: white;\n        }\n      #chat-room-box { display: none; }\n      #chat-room { width: 200px; }\n      #chat-name { width: 200px; }\n      #chat-video {\n        max-height: 40vh;\n        overflow: auto;\n        display: none;\n        padding: 10px;\n      }\n      #chat-video.visible {\n        display: grid;\n      }\n      #chat-audio {\n        max-height: 20vh;\n        overflow: auto;\n        display: none;\n        padding: 10px;\n      }\n      #chat-audio.visible { display: block; }\n      .audio-stream-container {\n        display: flex;\n        align-items: center;\n        gap: 10px;\n        padding: 8px;\n        margin-bottom: 5px;\n        background: rgba(0, 0, 0, 0.05);\n        border-radius: 5px;\n        border-left: 3px solid #4CAF50;\n      }\n      .audio-stream-indicator {\n        width: 12px;\n        height: 12px;\n        border-radius: 50%;\n        background: #4CAF50;\n        animation: pulse 2s infinite;\n      }\n      @keyframes pulse {\n        0%, 100% { opacity: 1; }\n        50% { opacity: 0.5; }\n      }\n      .audio-stream-label {\n        font-size: 0.9em;\n        color: #333;\n        flex: 1;\n      }\n      .audio-stream-controls {\n        display: flex;\n        gap: 5px;\n      }\n      .audio-stream-mute-btn {\n        padding: 4px 8px;\n        border: 1px solid #ccc;\n        border-radius: 3px;\n        background: white;\n        cursor: pointer;\n          font-size: 0.8em;\n        }\n      .audio-stream-mute-btn:hover { background: #f0f0f0; }\n      .audio-stream-mute-btn.muted {\n        background: #ffebee;\n        border-color: #f44336;\n      }\n      .audio-stream-element { display: none; }\n      .video-stream-container {\n        position: relative;\n        width: 100%;\n        max-width: 100%;\n          margin-bottom: 10px;\n        background: #000;\n        border-radius: 5px;\n        overflow: hidden;\n      }\n      .video-stream-container video {\n        width: 100%;\n        height: auto;\n        display: block;\n      }\n      .video-stream-remote { width: 100%; }\n      #chat-body {\n        max-height: 40vh;\n        overflow: auto;\n        display: none;\n        padding: 10px;\n      }\n      #chat-body.visible { display: block; }\n      #active-users { font-size: 0.8em; }\n      #messages { margin-bottom: 10px; }\n        #input-container {\n          margin-top: 30px;\n        display: flex;\n        align-items: center;\n        gap: 5px;\n      }\n      .call-button {\n        display: none;\n        cursor: pointer;\n        padding: 5px 10px;\n        border: 1px solid #ccc;\n        border-radius: 4px;\n        background-color: white;\n        font-size: 0.9em;\n      }\n      .call-button.visible { display: inline-block; }\n      .call-button.audio-call,\n      .call-button.video-call { color: green; }\n      .call-button.end-call,\n      .call-button.cancel { color: red; }\n      #input-message {\n        flex: 1;\n        padding: 5px;\n        border: 1px solid #ccc;\n        border-radius: 4px;\n      }\n      #input-message:disabled {\n        background-color: #f5f5f5;\n        cursor: not-allowed;\n      }\n      #emoji-button {\n        display: inline-block;\n        cursor: pointer;\n        padding: 5px 10px;\n        border: 1px solid #ccc;\n        border-radius: 4px;\n        background-color: white;\n      }\n      #emoji-button:disabled {\n        background-color: #f5f5f5;\n        cursor: not-allowed;\n      }\n      #clear-button {\n        cursor: pointer;\n        padding: 5px 10px;\n        border: 1px solid #ccc;\n        border-radius: 4px;\n        background-color: white;\n      }\n      #clear-button:disabled {\n        background-color: #f5f5f5;\n        cursor: not-allowed;\n      }\n      .message {\n        padding: 5px 10px;\n        margin: 5px;\n        border-radius: 10px;\n        max-width: 60%;\n      }\n      .message.own-message {\n        background-color: var(--primary-user-color);\n        color: white;\n        margin-left: auto;\n      }\n      .message.other-message {\n        color: black;\n        margin-right: auto;\n      }\n      .user-bubble {\n        height: 20px;\n        border-radius: 5px;\n        padding: 0px 5px;\n        display: inline-block;\n        text-align: center;\n        line-height: 20px;\n        color: white;\n        font-size: 12px;\n        cursor: pointer;\n        overflow: hidden;\n        white-space: nowrap;\n      }\n      .notification-message {\n        color: #666;\n        font-size: 0.85em;\n        font-style: italic;\n        margin-bottom: 5px;\n        padding: 5px;\n        border-radius: 3px;\n      }\n      .notification-message.missed-call {\n        background-color: #fff3cd;\n        border-left: 3px solid #ffc107;\n      }\n      .notification-message.declined-call {\n        background-color: #f8d7da;\n        border-left: 3px solid #dc3545;\n      }\n      @media only screen and (max-width: 1000px) {\n          #chat-container {\n            min-width: 50vw !important;\n          }\n      }\n    `}_cacheElements(){this.chatHeaderComponent=this.shadowRoot.getElementById("chat-header-component"),this.activeUsersComponent=this.shadowRoot.getElementById("active-users-component"),this.messagesComponent=this.shadowRoot.getElementById("messages-component"),this.messageInputComponent=this.shadowRoot.getElementById("message-input-component"),this.chatVideo=this.shadowRoot.getElementById("chat-video"),this.chatAudio=this.shadowRoot.getElementById("chat-audio"),this.chatBody=this.shadowRoot.getElementById("chat-body"),this.callManagement=this.shadowRoot.getElementById("call-management"),this.callManagementContainer=this.callManagement,this.audioCallButton=this.shadowRoot.getElementById("audio-call-button"),this.videoCallButton=this.shadowRoot.getElementById("video-call-button"),this.endCallButton=this.shadowRoot.getElementById("end-call-button"),this.messages=this.messagesComponent?this.messagesComponent.shadowRoot.querySelector(".messages"):null,this.activeUsers=this.activeUsersComponent?this.activeUsersComponent.shadowRoot.querySelector(".active-users"):null}_initializeComponents(){this.chatHeaderComponent&&(this.chatHeaderComponent.config={allowRoomChange:this.config.allowRoomChange,showRoom:this.config.showRoom,baseTopic:this.config.baseTopic,currentRoom:this.config.currentRoom,primaryUserColor:this.config.primaryUserColor}),this.activeUsersComponent&&(this.activeUsersComponent.config={userColors:this.config.userColors}),this.messagesComponent&&(this.messagesComponent.config={primaryUserColor:this.config.primaryUserColor,userColors:this.config.userColors}),this.messageInputComponent&&(this.messageInputComponent.config={callModes:this.config.callModes}),this.callManagement=null;const e=this.config.videoDisplayComponent||T;this.videoDisplay=new e(this.chatVideo,{localVideoSize:"25%",localVideoPosition:"top-right"}),this.audioDisplay=new M(this.chatAudio),this.ringer=new k({volume:this.config.ringerVolume}),this.notificationSound=new P({volume:this.config.notificationVolume}),this.callManager=null,this.chatManager=null,this.activeCallType=null,this.outgoingCalls=new Map,this.activeVideoCalls=new Set,this.activeAudioCalls=new Set,this.localStreams=new Map,this.pendingCalls=new Map,this.pinnedAudioCallMessage=null}_setupEventListeners(){this._setupCallButtons(),this._setupCallControls(),this._setupComponentEventListeners(),this.state.on("change:currentRoom",({value:e})=>{this.chatHeaderComponent&&this.chatHeaderComponent.setRoom(e)})}_setupComponentEventListeners(){this.chatHeaderComponent&&(this.chatHeaderComponent.addEventListener("roomchange",e=>{this.finishRoomEdit(e.detail.room)}),this.chatHeaderComponent.addEventListener("namechange",e=>{const t=e.detail.name;console.log("Name changed to "+t),this.rtc?(this.rtc.changeName(t),this.name=this.rtc.name,this.chatHeaderComponent.setName(this.name)):this.name=t}),this.chatHeaderComponent.addEventListener("togglecollapse",()=>{this._toggleCollapse()})),this.messageInputComponent&&(this.messageInputComponent.addEventListener("sendmessage",e=>{this.sendMessage(e.detail.message)}),this.messageInputComponent.addEventListener("emojiclick",()=>{this.sendMessage("ðŸ‘‹")}),this.messageInputComponent.addEventListener("clearclick",()=>{this.messagesComponent&&this.messagesComponent.clear()}),this.messageInputComponent.addEventListener("audiocallclick",()=>{const e=this.messageInputComponent.audioCallButton?.textContent;"End"===e||"Cancel"===e?"Cancel"===e?this._cancelOutgoingCall("audio"):this._endAllCalls():this._startCall("audio")}),this.messageInputComponent.addEventListener("videocallclick",()=>{const e=this.messageInputComponent.videoCallButton?.textContent;"End"===e||"Cancel"===e?"Cancel"===e?this._cancelOutgoingCall("video"):this._endAllCalls():this._startCall("video")}),this.messageInputComponent.addEventListener("endcallclick",()=>{this._endAllCalls()})),this.audioCallButton&&this.audioCallButton.addEventListener("click",()=>{console.log("Audio call button clicked");const e=this.audioCallButton.textContent;"End"===e||"Cancel"===e?this._endAllCalls():this._startCall("audio")}),this.videoCallButton&&this.videoCallButton.addEventListener("click",()=>{console.log("Video call button clicked");const e=this.videoCallButton.textContent;"End"===e||"Cancel"===e?this._endAllCalls():this._startCall("video")}),this.endCallButton&&this.endCallButton.addEventListener("click",()=>{console.log("End call button clicked"),this._endAllCalls()}),this.activeUsersComponent&&this.activeUsersComponent.addEventListener("userclick",e=>{alert("User: "+e.detail.user)})}_cancelOutgoingCall(e){}_initializeUI(){const e=this.shadowRoot.getElementById("room-display");e&&(this.config.showRoom?e.classList.remove("hidden"):e.classList.add("hidden")),this.callManagement&&this.callManagement.classList.add("hidden"),this.updateInputState(),this.chatBody&&this.chatBody.classList.add("visible")}_setupCallButtons(){}_toggleCollapse(){if(this.chatBody){if(this.chatBody.classList.contains("visible"))this.chatBody.classList.remove("visible"),this.callManagementContainer&&(this.callManagementContainer.style.display="none"),this.chatVideo&&(this.chatVideo.style.display="none"),this.chatAudio&&(this.chatAudio.style.display="none");else{if(this.chatBody.classList.add("visible"),this.callManagementContainer){const e=this.callManagementContainer.classList.contains("active");this.callManagementContainer.style.display=e?"flex":"none"}this.chatVideo&&(this.chatVideo.style.display=""),this.chatAudio&&(this.chatAudio.style.display="")}}}_setupCallControls(){}_toggleMicMute(){if(!this.callManager)return;const e=this.callManager.getMuteState();this.callManager.setMicMuted(!e.mic)}_toggleSpeakersMute(){if(this.isSpeakersMuted=!this.isSpeakersMuted,this.audioDisplay&&this.audioDisplay.activeStreams)for(const[e,t]of Object.entries(this.audioDisplay.activeStreams))if(t&&t.container){const e=t.container.querySelector('.audio-stream-element[data-type="remote"]');e&&(e.muted=this.isSpeakersMuted)}if(this.videoDisplay&&this.videoDisplay.activeStreams)for(const[e,t]of Object.entries(this.videoDisplay.activeStreams))if(t&&t.container){const e=t.container.querySelector(".video-stream-remote");e&&(e.muted=this.isSpeakersMuted)}this.callManagement&&this.callManagement.setMuteState({mic:this.isMicMuted}),this._updateCallControlsMessage()}_toggleVideo(){if(!this.callManager)return;const e=this.callManager.getMuteState();this.callManager.setVideoHidden(!e.video)}_updateCallControlsMessage(){if(!this.callManagement||!this.callManager)return;const e=this.callManager.getActiveCalls(),t=this.callManager.getMuteState();this.callManagement.setActiveCalls(e.audio,e.video),this.callManagement.setMuteState({mic:t.mic,speakers:t.speakers,video:t.video});for(const t of e.audio){const e=this.callManager.getMetrics(t);e&&this.callManagement.setMetrics(t,e)}for(const t of e.video){const e=this.callManager.getMetrics(t);e&&this.callManagement.setMetrics(t,e)}const n=e.video.size>0||e.audio.size>0,s=(this.chatManager?this.chatManager.getActiveUsers():[]).length>0;if(this.callManagementContainer){const e=(this.callManager&&"function"==typeof this.callManager.getPendingCalls?this.callManager.getPendingCalls():new Set).size>0;n||s||e?(this.callManagementContainer.classList.remove("hidden"),this.callManagementContainer.style.display="flex"):this.callManagementContainer.classList.add("hidden")}const i=this.shadowRoot.getElementById("call-controls-container"),o=this.shadowRoot.getElementById("call-info-container");i&&(n?i.classList.add("active"):i.classList.remove("active")),o&&(n?o.classList.add("active"):o.classList.remove("active"))}_handleCallTimeout(e,t){if(this._showMissedCallMessage(e,t),"incoming"===t&&this.messagesComponent){const t=`You missed ${e}'s call`;this.appendMessage({data:t,sender:"System",timestamp:Date.now(),isOwn:!1})}this.videoDisplay.removeStreams(e),this.audioDisplay.removeStreams(e);const n=this.callManager?this.callManager.getActiveCalls():{audio:new Set,video:new Set},s=n.video.size>0||n.audio.size>0;this.activeCallType=null,this._updateCallControlsVisibility(),this._updateCallButtonStates(s),this._updateCallButtonVisibility()}_updateCallControlsVisibility(){this._updateCallControlsMessage()}_updateCallButtonVisibility(){const e=(this.chatManager&&"function"==typeof this.chatManager.getActiveUsers?this.chatManager.getActiveUsers():[]).length>0,t=this.config.callModes,n=this.callManager?this.callManager.getActiveCalls():{audio:new Set,video:new Set},s=n.video.size>0||n.audio.size>0,i=(this.callManager&&"function"==typeof this.callManager.getPendingCalls?this.callManager.getPendingCalls():new Set).size>0,o=!!this.callManagementContainer&&!this.callManagementContainer.classList.contains("hidden");if(this.audioCallButton&&this.audioCallButton.classList.contains("visible"),this.videoCallButton&&this.videoCallButton.classList.contains("visible"),this.audioCallButton){const e=window.getComputedStyle(this.audioCallButton);console.log("Audio button state:",{element:this.audioCallButton,hasVisibleClass:this.audioCallButton.classList.contains("visible"),computedDisplay:e.display,computedVisibility:e.visibility,parentDisplay:this.audioCallButton.parentElement?window.getComputedStyle(this.audioCallButton.parentElement).display:"N/A",callManagementVisible:o,callManagementDisplay:this.callManagementContainer?window.getComputedStyle(this.callManagementContainer).display:"N/A"})}const a=this.shadowRoot.getElementById("call-buttons-container");if(i)return this.audioCallButton&&this.audioCallButton.classList.remove("visible"),void(this.videoCallButton&&this.videoCallButton.classList.remove("visible"));a&&0===a.children.length&&(this.audioCallButton&&!a.contains(this.audioCallButton)&&a.appendChild(this.audioCallButton),this.videoCallButton&&!a.contains(this.videoCallButton)&&a.appendChild(this.videoCallButton)),this.audioCallButton&&(this.audioCallButton.classList.remove("visible"),this.audioCallButton.style.display=""),this.videoCallButton&&(this.videoCallButton.classList.remove("visible"),this.videoCallButton.style.display=""),this.audioCallButton&&(this.audioCallButton.textContent="Start Audio Call"),this.videoCallButton&&(this.videoCallButton.textContent="Start Video Call"),!e||s||i||("both"===t?(this.audioCallButton&&this.audioCallButton.classList.add("visible"),this.videoCallButton&&this.videoCallButton.classList.add("visible")):"audio"===t?this.audioCallButton&&this.audioCallButton.classList.add("visible"):"video"===t&&this.videoCallButton&&this.videoCallButton.classList.add("visible"))}_startCall(e){if(console.log("_startCall called with type:",e),!this.callManager||!this.chatManager)return void console.warn("_startCall: callManager or chatManager not initialized",{callManager:!!this.callManager,chatManager:!!this.chatManager});const t=this.chatManager.getActiveUsers();if(0===t.length)return void console.warn("_startCall: No active users to call");this.ringer&&"function"==typeof this.ringer.stop&&this.ringer.stop(),this.activeCallType=e;if(t.length>=2)console.log(`Starting group ${e} call with ${t.length} users:`,t),this._updateCallButtonStates(!0,e,!0),this.callManager.startGroupCall("all",e).then(e=>{console.log("Group call started successfully:",e),console.log(`Successfully called ${e.successful.length} users, ${e.failed.length} failed`),e.failed.length>0&&console.warn("Some calls failed:",e.failed)}).catch(e=>{console.error("Error starting group call:",e),this.activeCallType=null,alert(`Failed to start group call: ${e.message||e}`)});else{const n=t[0];console.log("Starting individual call to:",n,"type:",e),this._updateCallButtonStates(!0,e,!0),this.callManager.startCall(n,e).then(e=>{console.log("Call started successfully:",e)}).catch(e=>{console.error("Error starting call:",e),this.activeCallType=null,this._updateCallButtonStates(!1)})}}_endAllCalls(){if(!this.callManager)return;this.ringer.stop(),this.callManager.endAllCalls();const e=this.callManager.getActiveCalls(),t=e.video.size>0||e.audio.size>0;this.activeCallType=null,this._updateCallButtonStates(t),this._updateCallButtonVisibility(),t||(this.chatVideo&&this.chatVideo.classList.remove("visible"),this.videoDisplay&&this.videoDisplay.container&&this.videoDisplay.hide()),this.callManagement&&"function"==typeof this.callManagement._updateFromCallManager&&this.callManagement._updateFromCallManager(),this._updateCallControlsVisibility()}_updateCallButtonStates(e,t=null,n=!1){const s=this.callManager?this.callManager.getActiveCalls():{audio:new Set,video:new Set},i=s.video.size>0||s.audio.size>0,o=(this.callManager&&"function"==typeof this.callManager.getPendingCalls?this.callManager.getPendingCalls():new Set).size>0,a=e||i,r=(this.chatManager?this.chatManager.getActiveUsers():[]).length>0,l=this.config.callModes,c=this.shadowRoot.getElementById("call-buttons-container");if(o)return this.audioCallButton&&this.audioCallButton.classList.remove("visible"),this.videoCallButton&&this.videoCallButton.classList.remove("visible"),void(this.endCallButton&&this.endCallButton.classList.remove("visible"));c&&0===c.children.length&&(this.audioCallButton&&!c.contains(this.audioCallButton)&&c.appendChild(this.audioCallButton),this.videoCallButton&&!c.contains(this.videoCallButton)&&c.appendChild(this.videoCallButton)),a&&t?n?"audio"===t&&this.audioCallButton?(this.audioCallButton.textContent="Cancel",this.audioCallButton.className="call-button cancel visible",this.videoCallButton&&this.videoCallButton.classList.remove("visible"),this.endCallButton&&this.endCallButton.classList.remove("visible")):"video"===t&&this.videoCallButton&&(this.videoCallButton.textContent="Cancel",this.videoCallButton.className="call-button cancel visible",this.audioCallButton&&this.audioCallButton.classList.remove("visible"),this.endCallButton&&this.endCallButton.classList.remove("visible")):(this.endCallButton&&this.endCallButton.classList.add("visible"),this.audioCallButton&&this.audioCallButton.classList.remove("visible"),this.videoCallButton&&this.videoCallButton.classList.remove("visible")):a&&!t?(this.endCallButton&&this.endCallButton.classList.add("visible"),this.audioCallButton&&this.audioCallButton.classList.remove("visible"),this.videoCallButton&&this.videoCallButton.classList.remove("visible")):(this.audioCallButton&&(this.audioCallButton.textContent="Audio",this.audioCallButton.className="call-button audio-call"),this.videoCallButton&&(this.videoCallButton.textContent="Video",this.videoCallButton.className="call-button video-call"),this.endCallButton&&this.endCallButton.classList.remove("visible"),r&&("both"===l?(this.audioCallButton&&this.audioCallButton.classList.add("visible"),this.videoCallButton&&this.videoCallButton.classList.add("visible")):"audio"===l?this.audioCallButton&&this.audioCallButton.classList.add("visible"):"video"===l&&this.videoCallButton&&this.videoCallButton.classList.add("visible")))}getConfig(){return{...this.config}}get callTimeout(){return this.config.callTimeout}set callTimeout(e){"number"==typeof e&&e>0?(this.config.callTimeout=e,this.callManager&&(this.callManager.options.callTimeout=e)):console.warn("callTimeout must be a positive number")}get storage(){return!this._storage&&"undefined"!=typeof window&&window.localStorage&&(this._storage={getItem:e=>{try{return localStorage.getItem(e)}catch(e){return null}},setItem:(e,t)=>{try{localStorage.setItem(e,t)}catch(e){}},removeItem:e=>{try{localStorage.removeItem(e)}catch(e){}}}),this._storage}set storage(e){this._storage=e}get showRoom(){return this.config.showRoom}set showRoom(e){this.config.showRoom=e;const t=this.shadowRoot.getElementById("room-display");t&&(e?t.classList.remove("hidden"):t.classList.add("hidden"))}get allowRoomChange(){return this.config.allowRoomChange}set allowRoomChange(e){if(this.config.allowRoomChange=e,this.chatHeaderComponent){this.chatHeaderComponent.config.allowRoomChange=e;const t=this.chatHeaderComponent.shadowRoot.getElementById("room-name");t&&(t.readOnly=!e)}}get callModes(){return this.config.callModes}set callModes(e){["audio","video","both"].includes(e)?(this.config.callModes=e,this._updateCallButtonVisibility()):console.warn('callModes must be "audio", "video", or "both"')}get videoDisplayComponent(){return this.config.videoDisplayComponent}set videoDisplayComponent(e){if(this.config.videoDisplayComponent=e,this._rtc&&this.chatVideo){const t=e||T;this.videoDisplay=new t(this.chatVideo,{localVideoSize:"25%",localVideoPosition:"top-right"})}}get rtc(){return this._rtc}set rtc(e){this._rtc=e,this.name=e.name,this.chatHeaderComponent&&this.chatHeaderComponent.setName(this.name);const t=e.baseTopic||"",n=e.topic||"";this.state.set("baseTopic",t);let s=n;if(t&&n.startsWith(t)){const e=n[t.length]||"/";s=n.substring(t.length+e.length)}this.state.set("currentRoom",s);const i=t&&n.startsWith(t)?n[t.length]||"/":"",o=t?`${t}${i}`:"";this.chatHeaderComponent&&(this.chatHeaderComponent.setRoom(s),this.chatHeaderComponent.setRoomPrefix(o)),this.chatManager=new U(e,{name:this.name,primaryUserColor:this.config.primaryUserColor,userColors:[...this.config.userColors],chatUI:this,notifications:this.notificationSound}),this.callManager=new R(e,{callTimeout:this.config.callTimeout,callUI:this,videoDisplay:this.videoDisplay,audioDisplay:this.audioDisplay,ringer:this.ringer,notifications:this.notificationSound,chatManager:this.chatManager}),this.callManagementContainer&&(this.callManagement=new I(this.callManagementContainer,this.callManager)),this._setupManagerEventListeners();this.chatManager.getHistory().forEach(e=>this.appendMessage(e)),this._updateActiveUsersDisplay()}_setupManagerEventListeners(){this.chatManager.on("message",({data:e,sender:t,timestamp:n})=>{this.appendMessage({data:e,sender:t,timestamp:n})}),this.chatManager.on("userconnected",({user:e})=>{this._updateActiveUsersDisplay(),this._updateCallButtonVisibility()}),this.chatManager.on("userdisconnected",({user:e})=>{this._updateActiveUsersDisplay(),this._updateCallButtonVisibility()}),this.callManager.on("incomingcall",({peerName:e,callInfo:t,promises:n})=>{this._handleIncomingCall(e,t,n),this._updateCallButtonVisibility()}),this.callManager.on("callconnected",({sender:e,localStream:t,remoteStream:n,type:s})=>{this._handleCallConnected(e,t,n,s)}),this.callManager.on("callended",({peerName:e})=>{this.hideIncomingCallPrompt(e),this._handleCallEnded(e)}),this.callManager.on("calltimeout",({peerName:e,direction:t})=>{this.hideIncomingCallPrompt(e),this._handleCallTimeout(e,t)}),this.callManager.on("callrejected",({user:e})=>{this._showCallDeclinedMessage(e)}),this.callManager.on("mutechanged",()=>{}),this.callManager.on("speakersmutechanged",({muted:e})=>{if(this.isSpeakersMuted=e,this.audioDisplay&&this.audioDisplay.activeStreams)for(const[t,n]of Object.entries(this.audioDisplay.activeStreams))if(n&&n.container){const t=n.container.querySelector('.audio-stream-element[data-type="remote"]');t&&(t.muted=e)}if(this.videoDisplay&&this.videoDisplay.activeStreams)for(const[t,n]of Object.entries(this.videoDisplay.activeStreams))if(n&&n.container){const t=n.container.querySelector(".video-stream-remote");t&&(t.muted=e)}})}finishRoomEdit(e=null){let t=e;if(!t&&this.chatHeaderComponent){const e=this.chatHeaderComponent.shadowRoot.getElementById("room-name");t=e?e.value.trim():null}if(!t)return;const n=this.state.get("currentRoom");t&&t!==n&&(this.state.set("currentRoom",t),this.chatHeaderComponent&&this.chatHeaderComponent.setRoom(t),this.dispatchEvent(new CustomEvent("roomchange",{detail:{room:t},bubbles:!0})))}cancelRoomEdit(){const e=this.state.get("currentRoom");this.chatHeaderComponent&&this.chatHeaderComponent.setRoom(e)}receiveRTCChat(e,t){}setHistory(e){this.chatManager&&e.forEach(e=>this.appendMessage(e))}send(e){this.chatManager?this.chatManager.sendMessage(e):console.warn("No chat manager available")}toggleChat(){this.chatBody.classList.toggle("visible")}getMessageInput(){return this.messageInputComponent?this.messageInputComponent.getValue():""}clearMessageInput(){this.messageInputComponent&&this.messageInputComponent.clear()}setInputEnabled(e){this.messageInputComponent&&this.messageInputComponent.setEnabled(e)}sendMessage(e){e=e||this.getMessageInput(),this.chatManager&&(this.chatManager.sendMessage(e),this.messagesComponent&&this.messagesComponent.appendMessage({data:e,sender:this.name+"( You )",timestamp:Date.now(),isOwn:!0})),this.clearMessageInput()}displayMessage(e){if(this.messagesComponent){const t=e.sender&&e.sender.includes("( You )");this.messagesComponent.appendMessage({...e,isOwn:t})}}appendMessage({data:e,sender:t,timestamp:n}){if(this.messagesComponent){const s=t&&t.includes("( You )");this.messagesComponent.appendMessage({data:e,sender:t,timestamp:n,isOwn:s})}}onConnectedToUser(e){this._updateActiveUsersDisplay()}updateActiveUsers(e){if(this.activeUsersComponent){const t=this.chatManager?e=>this.chatManager.getUserColor(e):null;this.activeUsersComponent.updateUsers(e,t)}this.updateInputState();const t=e.length>0,n=this.callManager?this.callManager.getActiveCalls():{audio:new Set,video:new Set},s=n.video.size>0||n.audio.size>0,i=(this.callManager&&"function"==typeof this.callManager.getPendingCalls?this.callManager.getPendingCalls():new Set).size>0;this.callManagementContainer?t||s||i?(this.callManagementContainer.classList.remove("hidden"),this.callManagementContainer.style.display="flex",console.log("Call management section shown, hasUsers:",t,"hasActiveCalls:",s,"hasPendingCalls:",i)):(this.callManagementContainer.classList.add("hidden"),console.log("Call management section hidden")):console.warn("callManagementContainer not found!"),this._updateCallButtonVisibility()}_updateActiveUsersDisplay(){if(!this.chatManager)return;const e=this.chatManager?this.chatManager.getActiveUsers():[];console.log("ChatBox: Updating active users display with",e),this.updateActiveUsers(e)}onDisconnectedFromUser(e){this._updateActiveUsersDisplay(),this._updateCallButtonStates(!1)}updateInputState(){const e=(this.chatManager?this.chatManager.getActiveUsers():[]).length>0;this.setInputEnabled(e)}showIncomingCallPrompt(e,t){return console.log("Incoming call from",e,"callInfo:",t),this.callManagement&&"function"==typeof this.callManagement.showIncomingCallPrompt?this.callManagement.showIncomingCallPrompt(e,t):Promise.resolve(!0)}hideIncomingCallPrompt(e){this.callManagement&&"function"==typeof this.callManagement.hideIncomingCallPrompt&&this.callManagement.hideIncomingCallPrompt(e)}showMissedCallNotification(e,t){this.callManagement&&"function"==typeof this.callManagement.showMissedCallNotification&&this.callManagement.showMissedCallNotification(e,t)}showCallDeclinedNotification(e){this.callManagement&&"function"==typeof this.callManagement.showCallDeclinedNotification&&this.callManagement.showCallDeclinedNotification(e)}updateCallButtonStates(e){this._updateCallButtonStates(e.inCall,e.callType||null,e.isOutgoing||!1)}_handleIncomingCall(e,t,n){return this.showIncomingCallPrompt(e,t)}onIncomingCall(e,t,n){return this._handleIncomingCall(e,t,n)}_handleCallConnected(e,t,n,s){console.log(`${s} call connected with ${e}`),this.ringer.stop(),this.hideIncomingCallPrompt(e),"audio"===s?(t instanceof MediaStream||n instanceof MediaStream)&&this.audioDisplay.setStreams(e,{localStream:t,remoteStream:n}):t instanceof MediaStream||n instanceof MediaStream?(this.videoDisplay.setStreams(e,{localStream:t,remoteStream:n}),this.chatVideo&&(this.chatVideo.classList.add("visible"),console.log("Video container displayed"))):console.warn("Invalid streams for video call:",{localStream:t,remoteStream:n}),this._updateCallControlsVisibility(),this._updateCallButtonStates(!0,s)}onCallConnected(e,t,n,s){this._handleCallConnected(e,t,n,s)}_handleCallEnded(e){console.log("ChatBox._handleCallEnded: Handling call ended for "+e),this.ringer&&"function"==typeof this.ringer.stop&&this.ringer.stop(),this.videoDisplay.removeStreams(e),this.audioDisplay.removeStreams(e);const t=this.callManager?this.callManager.getActiveCalls():{audio:new Set,video:new Set},n=this.callManager?this.callManager.getPendingCalls():new Set,s=t.video.size>0||t.audio.size>0;n.size,console.log("ChatBox._handleCallEnded: State after call ended - active:",t,"pending:",n),0===t.video.size&&(this.chatVideo&&this.chatVideo.classList.remove("visible"),this.videoDisplay&&this.videoDisplay.container&&this.videoDisplay.hide()),this._updatePinnedAudioCallMessage(),this.activeCallType=null,this._updateCallControlsVisibility(),this._updateCallButtonStates(s),this._updateCallButtonVisibility(),this.callManagement&&"function"==typeof this.callManagement._updateFromCallManager&&(console.log("ChatBox._handleCallEnded: Updating CallManagement UI"),this.callManagement._updateFromCallManager()),this.callManagementContainer&&(this.callManagementContainer.classList.remove("hidden"),this.callManagementContainer.style.display="flex"),!s&&this.chatVideo&&(this.chatVideo.classList.remove("visible"),this.videoDisplay&&this.videoDisplay.container&&this.videoDisplay.hide())}onCallEnded(e){this._handleCallEnded(e)}_legacyOnIncomingCall(e,t,n){let s=setTimeout(()=>{console.log(`Incoming call from ${e} timed out after ${this.config.callTimeout}ms`),this.ringer.stop(),this._showMissedCallMessage(e,"incoming");const t=this.pendingCalls.get(e);if(t){if(t.promptElement)try{t.promptElement.remove()}catch(e){console.warn("Could not remove prompt element:",e)}this.pendingCalls.delete(e)}if(this._rtc)try{this._rtc.endCallWithUser(e)}catch(e){console.warn("Error ending timed out call:",e)}this.videoDisplay.removeStreams(e),this.audioDisplay.removeStreams(e),this.activeVideoCalls.delete(e),this.activeAudioCalls.delete(e),this.localStreams.delete(e),this._updateCallControlsVisibility()},this.config.callTimeout);return this.pendingCalls.set(e,{callInfo:t,promises:n,timeoutId:s}),n.start.then(({localStream:t,remoteStream:n})=>{const i=this.pendingCalls.get(e);i&&i.timeoutId&&(clearTimeout(i.timeoutId),i.timeoutId=null),s&&(clearTimeout(s),s=null),this.ringer.stop(),this.pendingCalls.delete(e),console.log(`Call start promise resolved for ${e}`)}).catch(t=>{const n=this.pendingCalls.get(e);n&&n.timeoutId&&(clearTimeout(n.timeoutId),n.timeoutId=null),s&&(clearTimeout(s),s=null),this.ringer.stop(),this.pendingCalls.delete(e),console.error(`Call start promise rejected for ${e}:`,t)}),Promise.resolve(!0)}onCallEnded(e){this.ringer.stop();const t=this.pendingCalls.get(e);this.pendingCalls.delete(e);const n=this.outgoingCalls.get(e);if(n&&(n.timeoutId&&clearTimeout(n.timeoutId),this.outgoingCalls.delete(e)),t&&t.promptElement)try{t.promptElement.remove()}catch(e){console.warn("Could not remove prompt element:",e)}this.videoDisplay.removeStreams(e),this.audioDisplay.removeStreams(e),this.activeVideoCalls.delete(e),this.activeAudioCalls.delete(e),this.localStreams.delete(e),this._updatePinnedAudioCallMessage(),this._updateCallControlsVisibility(),this.activeCallType=null,this._updateCallButtonStates(!1)}_showMissedCallMessage(e,t){this.showMissedCallNotification(e,t)}_showCallDeclinedMessage(e){this.showCallDeclinedNotification(e)}_updatePinnedAudioCallMessage(){const e=this.callManager?this.callManager.getActiveCalls():{audio:new Set};if(e.audio.size>0){if(!this.pinnedAudioCallMessage){this.pinnedAudioCallMessage=document.createElement("div"),this.pinnedAudioCallMessage.id="pinned-audio-call-message",this.pinnedAudioCallMessage.className="pinned-audio-call";const e=this.messagesComponent?this.messagesComponent.shadowRoot?.querySelector("#messages")||this.messagesComponent:null;e&&e.firstChild?e.insertBefore(this.pinnedAudioCallMessage,e.firstChild):e&&e.appendChild(this.pinnedAudioCallMessage)}const t=Array.from(e.audio).join(", "),n=e.audio.size;this.pinnedAudioCallMessage.textContent=`ðŸ”Š Audio call active${n>1?"s":""} with: ${t}`,this.pinnedAudioCallMessage.classList.remove("hidden")}else if(this.pinnedAudioCallMessage){try{this.pinnedAudioCallMessage.remove()}catch(e){}this.pinnedAudioCallMessage=null}}onCallConnected(e,{localStream:t,remoteStream:n}){this.ringer.stop();const s=this.pendingCalls.get(e);s&&s.timeoutId&&clearTimeout(s.timeoutId),this.pendingCalls.delete(e),console.log("Call connected event with",e,{localStream:t,remoteStream:n,localVideoTracks:t?.getVideoTracks().length,localAudioTracks:t?.getAudioTracks().length,remoteVideoTracks:n?.getVideoTracks().length,remoteAudioTracks:n?.getAudioTracks().length});const i=t?.getVideoTracks().length>0||n?.getVideoTracks().length>0,o=t?.getAudioTracks().length>0||n?.getAudioTracks().length>0;console.log("Call type detection:",{hasVideo:i,hasAudio:o,sender:e});const a=i?"video":o?"audio":null;a&&(this.activeCallType=a),this._updateCallButtonStates(!0,a),i?(console.log("Setting up video call for",e),this.activeVideoCalls.add(e),this.videoDisplay.setStreams(e,{localStream:t,remoteStream:n}),t instanceof MediaStream&&this.localStreams.set(e,t),this.chatVideo&&(this.chatVideo.classList.add("visible"),console.log("Video container displayed")),this._updateCallControlsVisibility()):o?(console.log("Setting up audio call for",e),this.activeAudioCalls.add(e),this.audioDisplay.setStreams(e,{localStream:t,remoteStream:n}),t instanceof MediaStream&&this.localStreams.set(e,t),this._updateCallControlsVisibility()):console.warn("Call connected but no video or audio tracks detected for",e)}}customElements.get("chat-box")||customElements.define("chat-box",j);class ${constructor(e,t,n,s,i){this.setLocalSrc=t,this.setRemoteSrc=n,this.accept=this.accept.bind(this),this.close=this.close.bind(this),this.closeCall=this.closeCall.bind(this),this.endCall=this.endCall.bind(this),this.setStreamCount=this.setStreamCount.bind(this),this._rtc=null,e&&(this.rtc=e),this.pendingNames=[],this.localStream=null,this.remoteStreams={},s&&(this.hide=s),i&&(this.show=i)}get rtc(){if(!this._rtc)throw new Error("RTC not set");return this._rtc}set rtc(e){this._rtc=e,e.on("callconnected",this.accept),e.on("calldisconnected",this.endCall)}get name(){return this.rtc.name}call(e,t="end"){this.pendingNames.push(e);let{start:n,end:s}=this.rtc.callUser(e);return s=s.then(()=>{this.close(e)}),"end"===t?s:n}endCall(e="all"){if("all"===e)for(let e of Object.keys(this.remoteStreams))this.endCall(e);this.remoteStreams[e]&&this.rtc.endCallWithUser(e),this.closeCall(e)}accept(e,t){t instanceof Promise?t.then(t=>this.accept(e,t)):(this.pendingNames.includes(e)&&(this.pendingNames=this.pendingNames.filter(t=>t!==e)),this.localStream||(this.localStream=t.localStream,this.setLocalSrc(this.localStream)),this.setRemoteSrc(t.remoteStream,e),this.remoteStreams[e]=t.remoteStream,this.setStreamCount(Object.keys(this.remoteStreams).length))}closeCall(e){this.pendingNames=this.pendingNames.filter(t=>t!==e),this.setRemoteSrc(null,e);let t=this.remoteStreams[e];if(t){try{t.getTracks().forEach(e=>e.stop())}catch(e){}delete this.remoteStreams[e],this.setStreamCount(Object.keys(this.remoteStreams).length)}}setStreamCount(e){if(e)this.show();else{if(this.localStream){try{this.localStream.getTracks().forEach(e=>e.stop())}catch(e){}this.setLocalSrc(null),this.localStream=null}this.setLocalSrc(null),this.localStream=null,this.hide()}}hide(){}show(){}close(){this.endCall()}}class F extends D{constructor(e,t={}){super(t),this.rtc=e,this._window=this.options.window,this._assignToWindow=this.options.assignToWindow}_initializeRTCVideoChat(e){this.setLocalSrc=this.setLocalSrc.bind(this),this.setRemoteSrc=this.setRemoteSrc.bind(this),this.hide=this.hide.bind(this),this.show=this.show.bind(this),this.resize=this.resize.bind(this),this.rtcVC=new $(e,this.setLocalSrc,this.setRemoteSrc,this.hide,this.show),this._assignToWindow&&this._window&&(this._window.vc=this),this.call=this.rtcVC.call.bind(this.rtcVC),this.endCall=this.rtcVC.endCall.bind(this.rtcVC),this._window&&this._window.addEventListener("resize",this.resize)}setLocalSrc(e){throw new Error("setLocalSrc must be implemented by subclass")}setRemoteSrc(e){throw new Error("setRemoteSrc must be implemented by subclass")}show(){throw new Error("show must be implemented by subclass")}hide(){throw new Error("hide must be implemented by subclass")}resize(e=null){const t=e||this._window;if(!t)return;const n=t.innerWidth,s=t.innerHeight,i=this._getContainer();i&&(i.style.maxWidth=n>600?"50vw":"80vw",i.style.maxHeight=s>600?"50vh":"80vh")}_getContainer(){throw new Error("_getContainer must be implemented by subclass")}disconnectedCallback(){super.disconnectedCallback(),this._window&&this.resize&&this._window.removeEventListener("resize",this.resize),this._assignToWindow&&this._window&&this._window.vc===this&&delete this._window.vc}}class K extends F{constructor(e,t={}){super(e,t),this.shadowRoot.innerHTML='\n            <style>\n                #container {\n                    position: relative;\n                    width: 100%;\n                    height: 100%; /* Full height of the container */\n                    max-width: 50vw;\n                    max-height: 50vh;\n                    display: flex;\n                    justify-content: center;\n                    align-items: center;\n                }\n\n                #remoteVideo, #localVideo {\n                    max-width: 100%;\n                    height: auto; /* Maintain aspect ratio */\n                }\n\n                #remoteVideo {\n                    width: 100%; /* Full width of the container */\n                    max-width: 50vw;\n                    max-height: 50vh;\n                }\n\n                #localVideo {\n                    position: absolute;\n                    width: 20%; /* Smaller size for local video */\n                    top: 10px;\n                    right: 10px;\n                    border: 2px solid white;\n                    box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);\n                    max-height: 100%;\n                }\n\n            </style>\n            <div id="container">\n                <video id="remoteVideo" autoplay playsinline></video>\n                <video id="localVideo" autoplay playsinline muted></video>\n            </div>\n        ',this.localVideo=this.queryRoot("#localVideo"),this.remoteVideo=this.queryRoot("#remoteVideo"),this.container=this.queryRoot("#container"),this._initializeRTCVideoChat(e)}_initialize(){}_getContainer(){return this.container}setLocalSrc(e){this.localVideo&&(this.localVideo.srcObject=e)}setRemoteSrc(e){this.remoteVideo&&(this.remoteVideo.srcObject=e)}hide(){this.container&&(this.container.style.display="none")}show(){this.container&&(this.container.style.display="flex")}resize(){super.resize(this._window)}disconnectedCallback(){super.disconnectedCallback()}}customElements.get("video-chat")||customElements.define("video-chat",K);class O extends j{constructor(e,t=K){super(e||{});const n=e||{};this._config={...this.config,...n},this._VC=t,this._autoConfigApplied=!1,this._VC=t,this.showRoom=!1!==this._config.showRoom,this.allowRoomChange=!1!==this._config.allowRoomChange,this.prompt=this.prompt.bind(this),this.notify=this.notify.bind(this),this.connectionrequest=this.connectionrequest.bind(this),this._activeConnectionPrompts=new Map;let s=this._config.topic||localStorage.getItem("topic")||"chat";"object"==typeof s&&s.room&&(s=s.room),this.chatHeaderComponent&&this.chatHeaderComponent.setRoom(s),this.chatHeaderComponent&&this.chatHeaderComponent.addEventListener("roomchange",e=>{const t=e.detail.room;localStorage.setItem("topic",t),this.connectRTC(this._config)}),this.addEventListener("roomchange",e=>{const t=e.detail.room;localStorage.setItem("topic",t),this.connectRTC(this._config)}),this.connectRTC=this.connectRTC.bind(this),this.connectRTC(this._config),this.lastValidated=""}connectedCallback(){if(z.length>0&&!this._autoConfigApplied){const e=z.shift();if(this._autoConfigApplied=!0,Object.assign(this.config,e),this._config={...this._config,...e},this.showRoom=!1!==this._config.showRoom,this.allowRoomChange=!1!==this._config.allowRoomChange,this._config.topic){let e=this._config.topic;"object"==typeof e&&e.room&&(e=e.room),this.chatHeaderComponent&&this.chatHeaderComponent.setRoom(e),this.connectRTC&&this.connectRTC(this._config)}}super.connectedCallback&&super.connectedCallback()}connectRTC(e){let t=(e=e||{}).topic||localStorage.getItem("topic")||"chat";"object"==typeof t&&t.room&&(t=t.room),e.topic&&"string"!=typeof e.topic?e.topic.room||(e.topic.room=t):e.topic={room:e.topic||t},e.trustMode=e.trustMode||"moderate",this.rtc=new v(e),this.rtc.shouldTrust=e=>Promise.resolve(!0),this.rtc.on("connectionrequest",this.connectionrequest),this.rtc.on("validation",(e,t)=>{t?this.notify(`Trusted ${e}`):this.notify(`Validated ${e}`),this.callButton&&(this.callButton.style.display="block",this.callButton.title=`Call ${e}`),this.lastValidated=e}),this.rtc.on("callended",()=>{this.callButton&&(this.callButton.style.display="block"),this.endCallButton&&(this.endCallButton.style.display="none")}),this.rtc.on("validationfailure",(e,t)=>{this.notify(`Validation failed for ${e}`)})}notify(e){const t=this.messages||this.shadowRoot?.getElementById("messages");if(t){let n=document.createElement("div");n.innerHTML=e,n.style.color="gray",n.style.fontSize="0.8em",t.appendChild(n)}else console.warn("Cannot display notification: messages element not found",e)}_showMissedCallMessage(e,t){const n="incoming"===t?`Missed call from ${e}`:`${e} missed your call`,s=document.createElement("div");s.style.color="#666",s.style.fontSize="0.85em",s.style.fontStyle="italic",s.style.marginBottom="5px",s.style.padding="5px",s.style.backgroundColor="#fff3cd",s.style.borderLeft="3px solid #ffc107",s.style.borderRadius="3px",s.textContent=n;const i=this.messages||this.shadowRoot?.getElementById("messages");i&&(i.appendChild(s),i.scrollTop=i.scrollHeight)}connectionrequest(e,t){let{bareName:n,userInfo:s,providedPubKey:i,peerNames:o,knownPubKey:a,knownName:r,otherNamesForPubKey:l,otherPubKeyForName:c,completedChallenge:d,explanation:h,suspiciousness:u,category:m,trustLevel:g,trustLevelString:p}=t;console.log("connectionrequest",e,g,p,h,t);if("true"===localStorage.getItem("rtchat_autoAccept"))return console.log("Auto-accepting connection request from",e),Promise.resolve(!0);if(this._activeConnectionPrompts.has(e)){const t=this._activeConnectionPrompts.get(e);t&&t.element&&t.element.parentNode&&t.element.remove(),t&&t.reject&&t.reject(new Error("Replaced by new connection request")),this._activeConnectionPrompts.delete(e)}const C=t.hint||"",f=`Do you want to connect to ${e}${C}?`;let y,v;const b=new Promise((e,t)=>{y=e,v=t}),w=this.prompt(f,!0),S=w.element;return this._activeConnectionPrompts.set(e,{element:S,resolve:y,reject:v}),w.promise.then(t=>{this._activeConnectionPrompts.delete(e),y(t)}).catch(t=>{this._activeConnectionPrompts.delete(e),v(t)}),b}prompt(e,t=!1){let n=document.createElement("div");n.style.marginBottom="10px";let s=document.createElement("div");s.innerHTML=e,s.style.marginBottom="8px",n.appendChild(s);let i=document.createElement("div");i.style.display="flex",i.style.gap="8px",i.style.flexWrap="wrap";let o=document.createElement("button");o.innerHTML="Yes";let a,r,l=document.createElement("button");l.innerHTML="No",i.appendChild(o),i.appendChild(l);const c=new Promise((e,t)=>{a=e,r=t});if(o.onclick=()=>{n.remove(),a(!0)},l.onclick=()=>{n.remove(),r()},t){let e=document.createElement("button");e.innerHTML="Auto-accept everyone",e.onclick=()=>{localStorage.setItem("rtchat_autoAccept","true"),n.remove(),a(!0)},i.appendChild(e)}n.appendChild(i);const d=this.messages||this.shadowRoot?.getElementById("messages");return d&&d.appendChild(n),{promise:c,element:n}}promptWithOptions(e,t){let n=document.createElement("div");n.style.marginBottom="10px";let s=document.createElement("div");s.innerHTML=e,s.style.marginBottom="8px",n.appendChild(s);let i,o=document.createElement("div");o.style.display="flex",o.style.gap="8px",o.style.flexWrap="wrap";const a=new Promise((e,t)=>{i=e});t.forEach(e=>{let t=document.createElement("button");t.innerHTML=e.text,t.onclick=()=>{n.remove(),i(e.value)},o.appendChild(t)}),n.appendChild(o);const r=this.messages||this.shadowRoot?.getElementById("messages");return r&&r.appendChild(n),{promise:a,element:n}}}window.RTChat=O,window.SignedMQTTRTCClient=v;const z=[];function Q(){if(void 0!==import.meta&&import.meta.url)return import.meta.url;if("undefined"!=typeof document){const e=document.currentScript||Array.from(document.getElementsByTagName("script")).pop();if(e&&e.src)return e.src}return window.location.href}customElements.get("rtc-hat")||customElements.define("rtc-hat",O),["t","true","yes","y","1"].includes((new URL(Q()).searchParams.get("add")||"").toLowerCase())&&window.addEventListener("load",()=>{const e=new URL(Q()).searchParams,t={},n=e.get("showRoom");null!==n&&(t.showRoom=!["false","0","no","n","f"].includes(n.toLowerCase()));const s=e.get("editableRoom");null!==s&&(t.allowRoomChange=!["false","0","no","n","f"].includes(s.toLowerCase()));const i=e.get("defaultRoom");null!==i&&(t.topic=i),Object.keys(t).length>0&&z.push(t);const o=document.createElement("rtc-hat");document.body.appendChild(o)});export{h as BaseMQTTRTCClient,K as BasicVideoChat,j as ChatBox,s as ConfigPresets,l as DeferredPromise,r as EventEmitter,C as Keys,o as LocalStorageAdapter,d as MQTTLoader,g as MQTTRTCClient,a as MemoryAdapter,p as Peer,m as PromisefulMQTTRTCClient,n as RTCConfig,u as RTCConnection,O as RTChat,v as SignedMQTTRTCClient,i as StorageAdapter,c as TabManager};
