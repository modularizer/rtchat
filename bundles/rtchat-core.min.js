var RTChatCore=function(e){"use strict";function t(e){return e&&"object"==typeof e&&!Array.isArray(e)}function n(e,s){const o={...e};return t(e)&&t(s)&&Object.keys(s).forEach(i=>{t(s[i])?i in e?o[i]=n(e[i],s[i]):Object.assign(o,{[i]:s[i]}):Object.assign(o,{[i]:s[i]})}),o}class s{static getDefaults(){return{name:null,userInfo:{},mqtt:{broker:"wss://public:public@public.cloud.shiftr.io",clientId:null,username:null,password:null,reconnectPeriod:1e3,connectTimeout:3e4},webrtc:{iceServers:[{urls:"stun:stun.l.google.com:19302"},{urls:"stun:stun1.l.google.com:19302"},{urls:"stun:stun2.l.google.com:19302"},{urls:"stun:stun3.l.google.com:19302"},{urls:"stun:stun4.l.google.com:19302"}],iceTransportPolicy:"all",bundlePolicy:"balanced",rtcpMuxPolicy:"require"},topic:{base:"mrtchat",room:null,separator:"/"},storage:null,crypto:null,mqttLibrary:null,compression:{enabled:!0,library:"lz-string",threshold:100},connection:{autoConnect:!0,autoReconnect:!0,maxReconnectAttempts:1/0,reconnectDelay:1e3,connectionTimeout:3e4,autoAcceptConnections:!1},history:{enabled:!0,maxLength:1e3},tabs:{enabled:!0,pollInterval:250,timeout:300},debug:!1,logger:null,load:!0}}constructor(e={}){const t=this.normalizeUserConfig(e),s={name:null,userInfo:{},mqtt:{broker:"wss://public:public@public.cloud.shiftr.io",clientId:null,username:null,password:null,reconnectPeriod:1e3,connectTimeout:3e4},webrtc:{iceServers:[{urls:"stun:stun.l.google.com:19302"},{urls:"stun:stun1.l.google.com:19302"},{urls:"stun:stun2.l.google.com:19302"},{urls:"stun:stun3.l.google.com:19302"},{urls:"stun:stun4.l.google.com:19302"}],iceTransportPolicy:"all",bundlePolicy:"balanced",rtcpMuxPolicy:"require"},topic:{base:"mrtchat",room:null,separator:"/"},storage:null,crypto:null,mqttLibrary:null,compression:{enabled:!0,library:"lz-string",threshold:100},connection:{autoConnect:!0,autoReconnect:!0,maxReconnectAttempts:1/0,reconnectDelay:1e3,connectionTimeout:3e4,autoAcceptConnections:!1},history:{enabled:!0,maxLength:1e3},tabs:{enabled:!0,pollInterval:250,timeout:300},debug:!1,logger:null,load:!0};this.config=n(s,t),this.applyComputedDefaults(),this.validate(),this.normalize()}normalizeUserConfig(e){const t={...e};return"string"==typeof e.topic&&(t.topic={room:e.topic}),t}applyComputedDefaults(){this.config.name||(this.config.name=this.getDefaultName()),this.config.topic.room||(this.config.topic.room=this.getDefaultRoom()),(null===this.config.webrtc.iceServers||Array.isArray(this.config.webrtc.iceServers)&&0===this.config.webrtc.iceServers.length)&&(this.config.webrtc.iceServers=[{urls:"stun:stun.l.google.com:19302"},{urls:"stun:stun1.l.google.com:19302"},{urls:"stun:stun2.l.google.com:19302"},{urls:"stun:stun3.l.google.com:19302"},{urls:"stun:stun4.l.google.com:19302"}])}getDefaultName(){if("undefined"!=typeof window&&window.localStorage)try{const e=localStorage.getItem("rtchat_name")||localStorage.getItem("name");if(e&&!e.startsWith("anon"))return e}catch(e){}return`User #${Math.floor(1e3*Math.random())}`}getDefaultRoom(){if("undefined"!=typeof window&&window.location){const e=window.location.hostname,t=window.location.pathname.replace(/rtchat\/?/,"").replace(/index\.html$/,"").replace(/\.html$/,"").replace(/[^a-zA-Z0-9]/g,"");return["localhost","127.0.0.1"].includes(e)?t||"default":e+t}return"default"}validate(){if(this.config.name){if(this.config.name.includes("(")||this.config.name.includes(")")||this.config.name.includes("|"))throw new Error("Name cannot contain (, ), or |");if(this.config.name!==this.config.name.trim())throw new Error("Name cannot have leading or trailing spaces")}if(this.config.mqtt.broker)try{new URL(this.config.mqtt.broker)}catch(e){throw new Error(`Invalid MQTT broker URL: ${this.config.mqtt.broker}`)}if(this.config.webrtc.iceServers&&!Array.isArray(this.config.webrtc.iceServers)&&"string"!=typeof this.config.webrtc.iceServers)throw new Error("iceServers must be an array or string")}normalize(){if(!Array.isArray(this.config.webrtc.iceServers)){const e=this.config.webrtc.iceServers;"string"==typeof e?this.config.webrtc.iceServers=[{urls:e}]:e&&e.urls?this.config.webrtc.iceServers=[e]:this.config.webrtc.iceServers=[{urls:"stun:stun.l.google.com:19302"},{urls:"stun:stun1.l.google.com:19302"},{urls:"stun:stun2.l.google.com:19302"},{urls:"stun:stun3.l.google.com:19302"},{urls:"stun:stun4.l.google.com:19302"}]}this.config.webrtc.iceServers=this.config.webrtc.iceServers.map(e=>"string"==typeof e?{urls:e}:e),this.config.topic.separator&&this.config.topic.room.includes(this.config.topic.separator)}get name(){return this.config.name}get broker(){return this.config.mqtt.broker}get iceServers(){return this.config.webrtc.iceServers}get topic(){const e=this.config.topic.separator||"/";return`${this.config.topic.base}${e}${this.config.topic.room}`}get baseTopic(){return this.config.topic.base}get room(){return this.config.topic.room}getConfig(){return this.config}update(e){const t=this.normalizeUserConfig(e);this.config=n(this.config,t),this.applyComputedDefaults(),this.validate(),this.normalize()}}const o={default:()=>new s({}),performance:()=>new s({webrtc:{iceServers:[{urls:"stun:stun.l.google.com:19302"},{urls:"stun:stun1.l.google.com:19302"},{urls:"stun:stun2.l.google.com:19302"},{urls:"stun:stun3.l.google.com:19302"},{urls:"stun:stun4.l.google.com:19302"}],iceTransportPolicy:"all"},connection:{autoReconnect:!0,reconnectDelay:500}}),privacy:e=>new s({webrtc:{iceServers:e||[{urls:"stun:stun.l.google.com:19302"}]}}),development:(e="ws://localhost:1883")=>new s({mqtt:{broker:e},debug:!0}),production:()=>new s({compression:{enabled:!0},history:{maxLength:500},connection:{autoReconnect:!0,maxReconnectAttempts:10},debug:!1})};class i{constructor(){if(this.constructor===i)throw new Error("StorageAdapter is an abstract class and cannot be instantiated directly. Extend it instead.")}getItem(e){throw new Error("getItem must be implemented by subclass")}setItem(e,t){throw new Error("setItem must be implemented by subclass")}removeItem(e){throw new Error("removeItem must be implemented by subclass")}clear(){throw new Error("clear must be implemented by subclass")}key(e){throw new Error("key must be implemented by subclass")}get length(){throw new Error("length must be implemented by subclass")}}class r extends i{constructor(){if(super(),"undefined"==typeof window||!window.localStorage)throw new Error("localStorage is not available in this environment");this.storage=window.localStorage}getItem(e){try{return this.storage.getItem(e)}catch(e){return console.warn("localStorage.getItem failed:",e),null}}setItem(e,t){try{this.storage.setItem(e,t)}catch(e){if(console.warn("localStorage.setItem failed:",e),"QuotaExceededError"===e.name)throw new Error("Storage quota exceeded")}}removeItem(e){try{this.storage.removeItem(e)}catch(e){console.warn("localStorage.removeItem failed:",e)}}clear(){try{this.storage.clear()}catch(e){console.warn("localStorage.clear failed:",e)}}key(e){try{return this.storage.key(e)}catch(e){return console.warn("localStorage.key failed:",e),null}}get length(){try{return this.storage.length}catch(e){return 0}}}class a{constructor(){this.events={}}on(e,t){if("function"!=typeof t)throw new Error("Handler must be a function");return this.events[e]||(this.events[e]=[]),this.events[e].push(t),()=>this.off(e,t)}off(e,t){this.events[e]&&(this.events[e]=this.events[e].filter(e=>e!==t))}emit(e,...t){if(!this.events[e])return;[...this.events[e]].forEach(n=>{try{n(...t)}catch(t){console.error(`Error in event handler for ${e}:`,t)}})}once(e,t){const n=(...s)=>{t(...s),this.off(e,n)};return this.on(e,n)}removeAllListeners(e){e?delete this.events[e]:this.events={}}listenerCount(e){return this.events[e]?this.events[e].length:0}}class c{constructor(){this.promise=new Promise((e,t)=>{this.resolve=e,this.reject=t})}}class l{constructor(e,t){this.storage=e,this.config=t,this.tabID=null,this.interval=null,this.initialize()}initialize(){if(!this.config.tabs.enabled)return void(this.tabID=null);let e=JSON.parse(this.storage.getItem("tabs")||"[]");const t=Date.now(),n=1e3*this.config.tabs.timeout;for(let s of e){const o=this.storage.getItem("tabpoll_"+s);if(o){const i=new Date(1*o);("Invalid Date"==i||t-i>n)&&(this.storage.removeItem("tabpoll_"+s),e=e.filter(e=>e!==s),this.storage.setItem("tabs",JSON.stringify(e)))}else this.storage.removeItem("tabpoll_"+s),e=e.filter(e=>e!==s),this.storage.setItem("tabs",JSON.stringify(e))}e=JSON.parse(this.storage.getItem("tabs")||"[]");const s=e.length?Math.max(...e):-1,o=e.length?Math.min(...e):-1;this.tabID=o<10?s+1:0,e.push(this.tabID),this.storage.setItem("tabs",JSON.stringify(e)),this.storage.setItem("tabpoll_"+this.tabID,Date.now().toString()),this.interval=setInterval(()=>{this.storage.setItem("tabpoll_"+this.tabID,Date.now().toString())},this.config.tabs.pollInterval),this.config.debug&&console.log("Tab ID: ",this.tabID)}getTabID(){return this.tabID}cleanup(){if(this.interval&&(clearInterval(this.interval),this.interval=null),null!==this.tabID){let e=JSON.parse(this.storage.getItem("tabs")||"[]");e=e.filter(e=>e!==this.tabID),this.storage.setItem("tabs",JSON.stringify(e)),this.storage.removeItem("tabpoll_"+this.tabID)}}}class h{constructor(e){this.config=e,this.mqtt=null,this.compression=null,this.loading=!1}async load(){if(this.loading)return this.waitForLoad();if(this.loading=!0,this.config.mqttLibrary)return this.mqtt=this.config.mqttLibrary,this.loading=!1,this.mqtt;if("undefined"!=typeof window)return window.mqtt?(this.mqtt=window.mqtt,this.loading=!1,this.mqtt):this.loadFromCDN();throw new Error("MQTT library not available and cannot be loaded")}loadFromCDN(){return new Promise((e,t)=>{const n=document.createElement("script");n.src="https://unpkg.com/mqtt/dist/mqtt.min.js",n.onload=()=>{window.mqtt?(this.mqtt=window.mqtt,this.loadCompression().then(()=>{this.loading=!1,e(this.mqtt)})):(this.loading=!1,t(new Error("MQTT library failed to load")))},n.onerror=()=>{this.loading=!1,t(new Error("Failed to load MQTT library from CDN"))},document.head.appendChild(n)})}async loadCompression(){if(!this.config.compression.enabled)return;return"lz-string"===this.config.compression.library?window.LZString?void(this.compression=window.LZString):new Promise((e,t)=>{const n=document.createElement("script");n.src="https://cdnjs.cloudflare.com/ajax/libs/lz-string/1.4.4/lz-string.min.js",n.onload=()=>{window.LZString?(this.compression=window.LZString,e()):t(new Error("LZ-String library failed to load"))},n.onerror=()=>{t(new Error("Failed to load LZ-String library"))},document.head.appendChild(n)}):void 0}getMQTT(){return this.mqtt}getCompression(){return this.compression}compress(e){if(!this.compression||!this.config.compression.enabled)return e;const t="string"==typeof e?e:JSON.stringify(e);return t.length<this.config.compression.threshold?e:this.compression.compressToUint8Array?this.compression.compressToUint8Array(t):e}decompress(e){return this.compression&&this.config.compression.enabled&&this.compression.decompressFromUint8Array?this.compression.decompressFromUint8Array(e):e}waitForLoad(){return new Promise(e=>{const t=setInterval(()=>{!this.loading&&this.mqtt&&(clearInterval(t),e(this.mqtt))},100)})}}class d extends a{constructor(e){super();const t=(e=e||{})instanceof s?e:new s(e),n=t.getConfig(),o=e.storage||new r;let i=null;n.tabs.enabled&&(i=new l(o,n));const a=new h(n),c=i?i.getTabID():null;this.name=n.name+(c?"("+c+")":""),this.userInfo=n.userInfo||{},this.mqttBroker=n.mqtt.broker,this.iceServers=n.webrtc.iceServers,this.baseTopic=n.topic.base,this.topic=t.topic,this.config=t,this.storage=o,this.tabManager=i,this.mqttLoader=a,this.maxHistoryLength=n.history.maxLength,n.name.startsWith("anon")||n.name.startsWith("User #")||(o.setItem("name",n.name),o.setItem("rtchat_name",n.name));const d=!1!==e.load;this.load=this.load.bind(this),this._onMQTTConnect=this._onMQTTConnect.bind(this),this.onConnectedToMQTT=this.onConnectedToMQTT.bind(this),this._onMQTTMessage=this._onMQTTMessage.bind(this),this.onMQTTMessage=this.onMQTTMessage.bind(this),this.beforeunload=this.beforeunload.bind(this),this.postPubliclyToMQTTServer=this.postPubliclyToMQTTServer.bind(this);for(let[e,t]of Object.entries(this.mqttHandlers))this.mqttHandlers[e]=t.bind(this);this.changeName=this.changeName.bind(this),this.recordNameChange=this.recordNameChange.bind(this),this.onNameChange=this.onNameChange.bind(this),this.shouldConnectToUser=this.shouldConnectToUser.bind(this),this.connectToUser=this.connectToUser.bind(this),this.connectionToUser=this.connectionToUser.bind(this),this.connectionsToUsers=this.connectionsToUsers.bind(this),this.disconnectFromUser=this.disconnectFromUser.bind(this),this.onConnectedToUser=this.onConnectedToUser.bind(this),this.onDisconnectedFromUser=this.onDisconnectedFromUser.bind(this),this.onrtcdisconnectedFromUser=this.onrtcdisconnectedFromUser.bind(this),this.callUser=this.callUser.bind(this),this.callFromUser=this.callFromUser.bind(this),this.acceptCallFromUser=this.acceptCallFromUser.bind(this),this.oncallconnected=this.oncallconnected.bind(this),this.isConnectedToUser=this.isConnectedToUser.bind(this),this.sendOverRTC=this.sendOverRTC.bind(this),this.onrtcmessage=this.onrtcmessage.bind(this),this.onrtcerror=this.onrtcerror.bind(this),this.rtcConnections={},this.knownUsers={},this.pendingIceCandidates={},this.mqttHistory=[],this.announceInterval=null,d&&this.load();if(!1!==e.assignToWindow&&"undefined"!=typeof window)if(window.rtc){let e=window.rtc;console.warn("RTC already exists. Saving old RTC object to window.rtc.old,",e),e.name,window.rtc={oldName:e,name:this}}else window.rtc=this}async load(){await this.mqttLoader.load();const e=this.mqttLoader.getMQTT();if(!e)throw new Error("MQTT library not available");const t=this.config.getConfig(),n={clientId:t.mqtt?.clientId||this.baseTopic+this.name,username:t.mqtt.username,password:t.mqtt.password,reconnectPeriod:t.mqtt.reconnectPeriod,connectTimeout:t.mqtt.connectTimeout};this.client=e.connect(this.mqttBroker,n),this.client.on("connect",this._onMQTTConnect.bind(this)),this.client.on("message",this._onMQTTMessage.bind(this)),"undefined"!=typeof window&&window.addEventListener("beforeunload",this.beforeunload.bind(this))}_onMQTTConnect(){this.client.subscribe(this.topic,(e=>{if(e)console.error("Error subscribing to "+this.topic,e);else{console.log("subscribed to ",this.topic),this.postPubliclyToMQTTServer("connect",this.userInfo),this.onConnectedToMQTT();let e=0;this.announceInterval=setInterval(()=>{(!Object.keys(this.rtcConnections).some(e=>{const t=this.rtcConnections[e];return t&&"connected"===t.peerConnection.connectionState})||e<5)&&this.postPubliclyToMQTTServer("connect",this.userInfo),e++,e>=5&&this.announceInterval&&(clearInterval(this.announceInterval),this.announceInterval=setInterval(()=>{Object.keys(this.rtcConnections).some(e=>{const t=this.rtcConnections[e];return t&&"connected"===t.peerConnection.connectionState})||this.postPubliclyToMQTTServer("connect",this.userInfo)},3e4))},3e3)}}).bind(this))}onConnectedToMQTT(){console.log("Connected to MQTT: "+this.topic+" as "+this.name),this.emit("mqttconnected",this.topic,this.name)}_onMQTTMessage(e,t){if(e===this.topic){let e;try{const n=this.mqttLoader.decompress(t);e="string"==typeof n?JSON.parse(n):n}catch(n){e=JSON.parse(t)}if(e.sender===this.name)return;let n=e.subtopic;for(e.sent=!1,e.receiveTimestamp=Date.now(),this.mqttHistory.push(e);this.mqttHistory.length>this.maxHistoryLength;)this.mqttHistory.shift();console.log("Received MQTT message on "+this.topic+" subtopic "+n+" from "+e.sender,e.data),this.mqttHandlers[n]?this.mqttHandlers[n](e):(this.onMQTTMessage(n,e.data,e.sender,e.timestamp),console.warn("Unhandled message: "+n,e))}}onMQTTMessage(e,t,n,s){console.log("Received message from "+n+" on "+e,t),this.emit("mqttmessage",e,t,n,s)}beforeunload(){this.postPubliclyToMQTTServer("unload","disconnecting"),this.tabManager&&this.tabManager.cleanup()}disconnect(){for(let e of Object.keys(this.rtcConnections))this.disconnectFromUser(e);this.announceInterval&&(clearInterval(this.announceInterval),this.announceInterval=null),this.client&&(this.client.end(),this.client=null),this.tabManager&&this.tabManager.cleanup()}postPubliclyToMQTTServer(e,t){let n={sender:this.name,timestamp:Date.now(),subtopic:e,data:t},s=JSON.stringify(n);if(s.length,this.mqttLoader){const e=this.mqttLoader.compress(s);e!==s&&(s=e)}for(console.log("Sending message to "+this.topic+" subtopic "+e,t),this.client.publish(this.topic,s),n.sent=!0,this.mqttHistory.push(n);this.mqttHistory.length>this.maxHistoryLength;)this.mqttHistory.shift()}mqttHandlers={connect:e=>{console.log("Received notice that someone else connected:"+e.sender,e,e.data);const t=this.rtcConnections[e.sender];if(t){const n=t.peerConnection.connectionState,s=t.peerConnection.iceConnectionState;if("connected"===n&&("connected"===s||"completed"===s))return console.log("Already connected to "+e.sender+", ignoring connect message"),void(this.knownUsers[e.sender]=e.data);if("failed"!==n&&"closed"!==n&&"failed"!==s&&"closed"!==s)return console.log("Connection to "+e.sender+" is in progress ("+n+"), ignoring"),void(this.knownUsers[e.sender]=e.data);console.warn("Connection to "+e.sender+" is broken, disconnecting"),this.disconnectFromUser(e.sender)}this.knownUsers[e.sender]=e.data,this.shouldConnectToUser(e.sender,e.data).then(t=>{t&&this.connectToUser(e.sender)})},nameChange:e=>{this.recordNameChange(e.data.oldName,e.data.newName)},unload:e=>{this.disconnectFromUser(e.sender),delete this.knownUsers[e.sender]},RTCOffer:e=>{this.shouldConnectToUser(e.sender,e.data.userInfo).then(t=>{if(t){if(e.data.offer.target!=this.name)return;this.rtcConnections[e.sender]&&(console.warn("Already have a connection to "+e.sender+". Closing and reopening."),this.rtcConnections[e.sender].close()),this.rtcConnections[e.sender]=new u(this,e.sender),this.rtcConnections[e.sender].respondToOffer(e.data.offer.localDescription);let t=this.pendingIceCandidates[e.sender];t&&(console.log("Found pending ice candidate for "+e.sender),this.rtcConnections[e.sender].onReceivedIceCandidate(t),delete this.pendingIceCandidates[e.sender])}else console.warn("Not connecting to "+e.sender)})},RTCIceCandidate:e=>{if(e.data){let t=this.rtcConnections[e.sender];t?t.onReceivedIceCandidate(e.data):this.pendingIceCandidates[e.sender]=e.data}},RTCAnswer:e=>{if(e.data.target!=this.name)return;let t=this.rtcConnections[e.sender];t?t.receiveAnswer(e.data.localDescription):console.error("No connection found for "+e.sender)}};shouldConnectToUser(e,t){return Promise.resolve(!0)}callUser(e,t){let n;if(t instanceof MediaStream){let s=t;n=this.rtcConnections[e].startCall(s).then(e=>({localStream:s,remoteStream:e}))}else t=t||{video:!0,audio:!0},n=navigator.mediaDevices.getUserMedia(t).then(t=>this.rtcConnections[e].startCall(t).then(e=>({localStream:t,remoteStream:e})));return{start:n,end:this.rtcConnections[e].callEndPromise.promise}}endCallWithUser(e){console.log("Ending call with "+e),this.rtcConnections[e]&&this.rtcConnections[e].endCall()}callFromUser(e,t,n,s){return t=t||{video:!0,audio:!0},n?navigator.mediaDevices.getUserMedia(t):this.acceptCallFromUser(e,t,s).then(e=>e?navigator.mediaDevices.getUserMedia(t):Promise.reject("Call rejected"))}oncallended(e){console.log("Call ended with "+e)}acceptCallFromUser(e,t,n){return Promise.resolve(!0)}connectToUser(e){if(this.rtcConnections[e]){console.warn("Already connected to "+e);try{this.disconnectFromUser(e)}catch{}delete this.rtcConnections[e]}if(!this.connectionToUser(e))return this.rtcConnections[e]=new u(this,e),this.rtcConnections[e].sendOffer(),this.rtcConnections[e]}connectionToUser(e){let t=this.rtcConnections[e];return t&&"connected"===t.peerConnection.connectionState?t:t?(console.warn("Already have a connection to "+e+" but it's not connected.",t.peerConnection.connectionState),"failed"==t.peerConnection.connectionState?(console.warn("Connection failed. Closing and reopening."),this.disconnectFromUser(e),null):t):null}connectionsToUsers(e){return"string"==typeof(e=e||Object.keys(this.rtcConnections))&&(e=[e]),e.filter(e=>this.connectionToUser(e))}get connectedUsers(){return this.connectionsToUsers()}disconnectFromUser(e){console.warn("Closing connection to "+e);let t=this.rtcConnections[e];t?(t.close(),delete this.rtcConnections[e],console.warn("Closed connection to "+e)):console.warn("No connection to close to "+e)}onConnectedToUser(e){console.log("Connected to user ",e),this.emit("connectedtopeer",e)}isConnectedToUser(e){return this.rtcConnections[e]&&"connected"===this.rtcConnections[e].peerConnection.connectionState}onrtcdisconnectedFromUser(e){this.rtcConnections[e]?(console.log("Disconnected from user ",e),delete this.rtcConnections[e],this.onDisconnectedFromUser(e)):console.warn("Already disconnected from"+e)}onDisconnectedFromUser(e){console.log("Disconnected from user ",e),this.emit("disconnectedfrompeer",e)}changeName(e){this.name;const t=this.tabManager?this.tabManager.getTabID():void 0!==t?t:null;this.name=e+(t?"("+t+")":""),this.storage?(this.storage.setItem("name",e),this.storage.setItem("rtchat_name",e)):"undefined"!=typeof localStorage&&localStorage.setItem("name",e),this.postPubliclyToMQTTServer("nameChange",{oldName:this.name,newName:e})}recordNameChange(e,t){this.knownUsers[t]=this.knownUsers[e],delete this.knownUsers[e],this.rtcConnections[t]=this.rtcConnections[e],delete this.rtcConnections[e],this.onNameChange(e,t)}onNameChange(e,t){console.log(e+" changed name to "+t)}sendOverRTC(e,t,n){if(!e)throw new Error("No channel specified");if(!this.rtcHandlers[e])throw new Error("Unsupported RTC channel: "+e);let s=this.rtcHandlers[e],o=t=t||e;s&&!s.raw&&(o=(s.serializer||JSON.stringify)(t));for(let s of this.connectionsToUsers(n))if(this.verifyUser(e,t,s)){const t=this.rtcConnections[s].send(e,o);t&&"function"==typeof t.then&&t.catch(t=>{console.error(`Failed to send on channel ${e} to ${s}:`,t)})}else console.warn("Not connected to "+s)}verifyUser(e,t,n){return!0}rtcHandlers={connectedViaRTC:(e,t)=>{this.onConnectedToUser(t)}};onrtcmessage(e,t,n){let s=this.rtcHandlers[e],o=t;s&&!s.raw&&(o=(s.deserializer||JSON.parse)(t)),s?s(o,n):console.warn("No handler found for "+e),this.emit("rtcmessage",e,o,n)}onrtcerror(e,t,n){let s=this.rtcHandlers[e];s&&s.error&&s.error(t,n)}}class u{constructor(e,t){const n=e.iceServers||(e.stunServer?[{urls:e.stunServer}]:[{urls:"stun:stun4.l.google.com:19302"}]);this.rtcConfiguration={iceServers:n,iceTransportPolicy:e.config?.getConfig()?.webrtc?.iceTransportPolicy||"all",bundlePolicy:e.config?.getConfig()?.webrtc?.bundlePolicy||"balanced",rtcpMuxPolicy:e.config?.getConfig()?.webrtc?.rtcpMuxPolicy||"require"},this.target=t,this.mqttClient=e,this.dataChannels={},this.peerConnection=new RTCPeerConnection(this.rtcConfiguration),this.peerConnection.onicecandidate=this.onicecandidate.bind(this),this.startCall=this.startCall.bind(this),this.onTrack=this.onTrack.bind(this),this.sentOffer=!1,this.streamChannels=["streamice","streamoffer","streamanswer","endcall"],this.dataChannelDeferredPromises=Object.fromEntries(Object.entries(e.rtcHandlers).map(([e,t])=>[e,new c])),this.streamChannels.forEach(e=>this.dataChannelDeferredPromises[e]=new c),this.loadPromise=Promise.all(Object.values(this.dataChannelDeferredPromises).map(e=>e.promise)),this.loaded=!1,this.loadPromise.then((()=>{this.loaded=!0}).bind(this)),this.peerConnection.ondatachannel=(e=>{this.registerDataChannel(e.channel)}).bind(this),this.peerConnection.oniceconnectionstatechange=function(){"disconnected"!==this.peerConnection.iceConnectionState&&"failed"!==this.peerConnection.iceConnectionState&&"closed"!==this.peerConnection.iceConnectionState||this.mqttClient.onDisconnectedFromUser(this.target)}.bind(this),this.pendingStreamIceCandidate=null,this.streamConnection=null,this.remoteStream=null,this.localStream=null,this.sendstreamice=!1,this.initiatedCall=!1,this.streamConnectionPromise=new c,this.streamPromise=new c,this.callEndPromise=new c,this.callPromises={start:this.streamPromise.promise,end:this.callEndPromise.promise}}registerDataChannel(e){e.onmessage=(t=>{this.onmessage(t,e.label)}).bind(this),e.onerror=(t=>{this.dataChannelDeferredPromises[e.label].reject(t),this.ondatachannelerror(t,e.label)}).bind(this),e.onopen=(t=>{this.dataChannelDeferredPromises[e.label].resolve(t)}).bind(this),this.dataChannels[e.label]=e}setupDataChannels(){for(let[e,t]of Object.entries(this.mqttClient.rtcHandlers)){let t=this.peerConnection.createDataChannel(e);this.registerDataChannel(t)}this.streamChannels.forEach(e=>{let t=this.peerConnection.createDataChannel(e);this.registerDataChannel(t)})}startCall(e){this.initiatedCall=!0;let t={video:!0,audio:!0};return this.streamConnection=this._makeStreamConnection(e),this.streamConnection.createOffer().then(e=>this.streamConnection.setLocalDescription(e)).then(()=>{this.send("streamoffer",JSON.stringify({offer:this.streamConnection.localDescription,streamInfo:t}))}),this.callPromises={start:this.streamPromise.promise,end:this.callEndPromise.promise},this.streamPromise.promise}_makeStreamConnection(e){if(!this.streamConnection)return this.localStream=e,this.streamConnection=new RTCPeerConnection(this.rtcConfiguration),e.getTracks().forEach(t=>this.streamConnection.addTrack(t,e)),this.streamConnection.onicecandidate=this.onstreamicecandidate.bind(this),this.streamConnection.ontrack=this.onTrack,this.streamConnectionPromise.resolve(this.streamConnection),this.callPromises={start:this.streamPromise.promise,end:this.callEndPromise.promise},this.streamConnection;console.warn("Already have a stream connection")}onTrack(e){console.warn("Track event",e),this.remoteStream=e.streams[0];let t={localStream:this.localStream,remoteStream:this.remoteStream};this.streamPromise.resolve(t),this.mqttClient.oncallconnected(this.target,t)}sendOffer(){this.setupDataChannels(),this.peerConnection.createOffer().then(e=>this.peerConnection.setLocalDescription(e)).then(()=>{console.log("Sending offer to "+this.target),this.mqttClient.postPubliclyToMQTTServer("RTCOffer",{userInfo:this.mqttClient.userInfo,offer:{localDescription:this.peerConnection.localDescription,target:this.target}})}),this.sentOffer=!0}respondToOffer(e){this.peerConnection.setRemoteDescription(new RTCSessionDescription(e)).then(()=>this.peerConnection.createAnswer()).then(e=>this.peerConnection.setLocalDescription(e)).then(e=>{this.mqttClient.postPubliclyToMQTTServer("RTCAnswer",{localDescription:this.peerConnection.localDescription,target:this.target})})}receiveAnswer(e){"have-local-offer"===this.peerConnection.signalingState?(this.peerConnection.setRemoteDescription(new RTCSessionDescription(e)),this.loadPromise.then((()=>{this.send("connectedViaRTC",null),this.mqttClient.onConnectedToUser(this.target)}).bind(this))):console.warn("Wrong state "+this.peerConnection.signalingState)}send(e,t){let n=this.dataChannels[e];if(!n)throw this.mqttClient.rtcHandlers[e]&&console.warn("handler found for ",e,"but no data channel"),new Error("No data channel for "+e);if("open"!==n.readyState){if("closed"===n.readyState)throw new Error("Channel closed: "+e);return new Promise((s,o)=>{const i=setTimeout(()=>{o(new Error(`Channel ${e} did not open within 10 seconds`))},1e4),r=()=>{clearTimeout(i),n.removeEventListener("open",r),n.removeEventListener("error",a);try{n.send(t),s()}catch(e){o(e)}},a=t=>{clearTimeout(i),n.removeEventListener("open",r),n.removeEventListener("error",a),o(new Error(`Channel ${e} error: ${t.message||t}`))};n.addEventListener("open",r),n.addEventListener("error",a)})}n.send(t)}onmessage(e,t){if("streamoffer"===t){console.log("received stream offer",e.data);let{offer:t,streamInfo:n}=JSON.parse(e.data);this.mqttClient.callFromUser(this.target,{video:!0,audio:!0},this.initiatedCall,this.callPromises).then(e=>(this.streamConnection||(this.streamConnection=this._makeStreamConnection(e)),this.streamConnection)).catch(e=>{this.streamConnectionPromise.reject(e),this.streamPromise.reject(e)}).then(e=>{e.setRemoteDescription(new RTCSessionDescription(t)).then(()=>this.streamConnection.createAnswer()).then(e=>this.streamConnection.setLocalDescription(e)).then(()=>{console.log("Sending stream answer",this.streamConnection.localDescription),this.send("streamanswer",JSON.stringify({answer:this.streamConnection.localDescription})),this.pendingStreamIceCandidate&&(console.log("Found pending stream ice candidate"),this.streamConnection.addIceCandidate(new RTCIceCandidate(this.pendingStreamIceCandidate)),this.pendingStreamIceCandidate=null)})})}else if("streamanswer"===t){console.log("received stream answer",e.data);let{answer:t}=JSON.parse(e.data);this.streamConnection.setRemoteDescription(new RTCSessionDescription(t))}else"streamice"===t?(console.log("received stream ice",e.data),e.data&&(this.streamConnection?this.streamConnection.addIceCandidate(new RTCIceCandidate(JSON.parse(e.data))):this.pendingStreamIceCandidate=JSON.parse(e.data))):"endcall"===t?this._closeCall():this.mqttClient.onrtcmessage(t,e.data,this.target)}endCall(){this.send("endcall",null),this._closeCall()}_closeCall(){this.streamConnection&&(this.streamConnection.close(),this.localStream.getTracks().forEach(e=>e.stop()),this.remoteStream.getTracks().forEach(e=>e.stop()),this.remoteStream=null,this.localStream=null),this.callEndPromise.resolve(),this.callEndPromise=new c,this.callRinging=!1,this.initiatedCall=!1,this.streamConnection=null,this.pendingStreamIceCandidate=null,this.streamConnectionPromise=new c,this.streamPromise=new c,this.callEndPromise=new c,this.callPromises={start:this.streamPromise.promise,end:this.callEndPromise.promise},this.mqttClient.oncallended(this.target)}onReceivedIceCandidate(e){this.peerConnection.addIceCandidate(new RTCIceCandidate(e))}onicecandidate(e){this.mqttClient.postPubliclyToMQTTServer("RTCIceCandidate",e.candidate)}onstreamicecandidate(e){e.candidate&&(console.log("Sending stream ice",this,e.candidate),this.send("streamice",JSON.stringify(e.candidate)))}ondatachannel(e){let t=e.channel;this.dataChannels[e.name]=t,t.onmessage=this.onmessage.bind(this)}ondatachannelerror(e,t){this.mqttClient.onrtcerror(t,e,this.target)}close(){this.closed||(this.peerConnection.close(),this.closed=!0,this.peerConnection=null,this.mqttClient.onrtcdisconnectedFromUser(this.target))}}class m extends d{constructor(e){e=e||{};let{name:t,userInfo:n,questionHandlers:s,handlers:o,load:i}=e;void 0===i&&(i=!0),e.load=!1,super(e),Object.assign(this.rtcHandlers,this.extraRTCHandlers),Object.assign(this.rtcHandlers,o||{});for(let[e,t]of Object.entries(this.rtcHandlers))this.rtcHandlers[e]=t.bind(this);s?this.questionHandlers=s:this.questionHandlers||(this.questionHandlers={}),this.questionPromises={},this.latestPings={},this.questionNumber=0,this.mqttConnected=new c,this.nextUserConnection=new c,this.nextUserDisconnectionPromises={},this.nextDMPromises={},this.nextChatPromises={},this.nextQuestionPromises={},this.nextAnswerPromises={},this.nextPingPromises={},this.nextPongPromises={},this.nextMQTTMessagePromises={},this.onConnectedToMQTT=this.onConnectedToMQTT.bind(this),this.sendRTCDM=this.sendRTCDM.bind(this),this.onRTCDM=this.onRTCDM.bind(this),this.sendRTCChat=this.sendRTCChat.bind(this),this.onRTCChat=this.onRTCChat.bind(this),this.onConnectedToUser=this.onConnectedToUser.bind(this),this.onDisconnectedFromUser=this.onDisconnectedFromUser.bind(this),this.sendRTCQuestion=this.sendRTCQuestion.bind(this),this.onRTCQuestion=this.onRTCQuestion.bind(this),this.respondToQuestion=this.respondToQuestion.bind(this),this.onRTCAnswer=this.onRTCAnswer.bind(this),this.pingEveryone=this.pingEveryone.bind(this),this.ping=this.ping.bind(this),this.receivedPing=this.receivedPing.bind(this),this.receivedPong=this.receivedPong.bind(this),this.nextUserDisconnection=this.nextUserDisconnection.bind(this),this.nextMQTTMessage=this.nextMQTTMessage.bind(this),this.nextAnswer=this.nextAnswer.bind(this),this.nextQuestion=this.nextQuestion.bind(this),this.nextChat=this.nextChat.bind(this),this.nextDM=this.nextDM.bind(this),this.nextPing=this.nextPing.bind(this),this.nextPong=this.nextPong.bind(this),this.addQuestionHandler=this.addQuestionHandler.bind(this),i&&this.load()}addQuestionHandler(e,t){this.questionHandlers[e]=t}extraRTCHandlers={dm:(e,t)=>{this.onRTCDM(e,t),this.nextDMPromises.anyone&&(this.nextDMPromises.anyone.resolve([e,t]),delete this.nextDMPromises.anyone),this.nextDMPromises[t]&&(this.nextDMPromises[t].resolve(e),delete this.nextDMPromises[t])},chat:(e,t)=>{this.onRTCChat(e,t),this.nextChatPromises.anyone&&(this.nextChatPromises.anyone.resolve([e,t]),delete this.nextChatPromises.anyone),this.nextChatPromises[t]&&(this.nextChatPromises[t].resolve(e),delete this.nextChatPromises[t])},question:(e,t)=>{this.onRTCQuestion(e,t),this.nextQuestionPromises.anyone&&(this.nextQuestionPromises.anyone.resolve([e,t]),delete this.nextQuestionPromises.anyone),this.nextQuestionPromises[t]&&(this.nextQuestionPromises[t].resolve(e),delete this.nextQuestionPromises[t])},answer:(e,t)=>{this.onRTCAnswer(e,t),this.nextAnswerPromises.anyone&&(this.nextAnswerPromises.anyone.resolve([e,t]),delete this.nextAnswerPromises.anyone),this.nextAnswerPromises[t]&&(this.nextAnswerPromises[t].resolve(e),delete this.nextAnswerPromises[t])},ping:(e,t)=>{this.sendOverRTC("pong",null,t),this.receivedPing(t),this.nextPingPromises.anyone&&(this.nextPingPromises.anyone.resolve([e,t]),delete this.nextPingPromises.anyone),this.nextPingPromises[t]&&(this.nextPingPromises[t].resolve(e),delete this.nextPingPromises[t])},pong:(e,t)=>{this.latestPings[t].resolve(),this.receivedPong(t),this.nextPongPromises.anyone&&(this.nextPongPromises.anyone.resolve([e,t]),delete this.nextPongPromises.anyone),this.nextPongPromises[t]&&(this.nextPongPromises[t].resolve(e),delete this.nextPongPromises[t])}};onConnectedToMQTT(){this.mqttConnected.resolve(),console.log("Connected to MQTT")}postPubliclyToMQTTServer(e,t){super.postPubliclyToMQTTServer(e,t)}onMQTTMessage(e,t,n,s){console.log("Received message from "+n+" on "+e,t),this.nextMQTTMessagePromises.anysubtopic&&(this.nextMQTTMessagePromises.anysubtopic.resolve([t,n,s]),delete this.nextMQTTMessagePromises.anysubtopic),this.nextMQTTMessagePromises[e]&&(this.nextMQTTMessagePromises[e].resolve([t,n,s]),delete this.nextMQTTMessagePromises[e]),super.onMQTTMessage(e,t,n,s)}onConnectedToUser(e){console.log("Connected to user ",e),this.nextUserConnection.resolve(e),this.nextUserConnection=new c}onDisconnectedFromUser(e){console.log("Disconnected from user ",e),this.nextUserDisconnection.resolve(e),this.nextUserDisconnectionPromises.anyone&&(this.nextUserDisconnectionPromises.anyone.resolve(e),delete this.nextUserDisconnectionPromises.anyone),this.nextUserDisconnectionPromises[e]&&(this.nextUserDisconnectionPromises[e].resolve(e),delete this.nextUserDisconnectionPromises[e])}sendRTCDM(e,t){this.sendOverRTC("dm",e,t)}onRTCDM(e,t){console.log("Received DM from "+t,e)}nextDM(e="anyone"){return this.nextDMPromises[e]=new c,this.nextDMPromises[e].promise}nextChat(e="anyone"){return this.nextChatPromises[e]=new c,this.nextChatPromises[e].promise}nextQuestion(e="anyone"){return this.nextQuestionPromises[e]=new c,this.nextQuestionPromises[e].promise}nextAnswer(e="anyone"){return this.nextAnswerPromises[e]=new c,this.nextAnswerPromises[e].promise}nextPing(e="anyone"){return this.nextPingPromises[e]=new c,this.nextPingPromises[e].promise}nextPong(e="anyone"){return this.nextPongPromises[e]=new c,this.nextPongPromises[e].promise}nextUserDisconnection(e="anyone"){return this.nextUserDisconnectionPromises[e]=new c,this.nextUserDisconnectionPromises[e].promise}nextMQTTMessage(e="anysubtopic"){return this.nextMQTTMessagePromises[e]=new c,this.nextMQTTMessagePromises[e].promise}sendRTCChat(e){this.sendOverRTC("chat",e)}onRTCChat(e,t){console.log("Received chat from "+t,e)}sendRTCQuestion(e,t,n){let s={topic:e,content:t},o=this.questionNumber;this.questionNumber++;let i=new c;this.questionPromises[o]=i;let r={n:o,question:s};return this.sendOverRTC("question",r,n),i.promise}onRTCQuestion(e,t){let{n:n,question:s}=e,o=this.respondToQuestion(s,t);o instanceof Promise?o.then(e=>{this.sendOverRTC("answer",{n:n,answer:e,question:s},t)}):this.sendOverRTC("answer",{n:n,answer:o,question:s},t)}respondToQuestion(e,t){let{topic:n,content:s}=e;if(this.questionHandlers[n])return this.questionHandlers[n](s,t);throw console.warn("No handler found for question "+n),new Error("No handler found for question "+n)}onRTCAnswer(e,t){let{n:n,answer:s}=e;this.questionPromises[n]?(this.questionPromises[n].resolve(s),delete this.questionPromises[n]):console.warn("No promise found for question "+n)}pingEveryone(){this.latestPings={};for(let e of this.connectedUsers)this.ping(e);return Promise.all(Object.values(this.latestPings).map(e=>e.promise))}ping(e){return this.latestPings[e]=new c,this.sendOverRTC("ping","ping",users),this.latestPings[e].promise}receivedPing(e){console.log("Received ping from "+e)}receivedPong(e){console.log("Received pong from "+e)}}class g extends m{constructor(e){e=e||{};let{name:t,userInfo:n,questionHandlers:s,handlers:o,load:i}=e;void 0===i&&(i=!0),e.load=!1,super(e),i&&this.load()}on(e,t){return"connectionrequest"===e?(this.shouldConnectToUser=t.bind(this),super.on(e,t)):"call"===e?(this.acceptCallFromUser=t.bind(this),super.on(e,t)):"callended"===e?(this.oncallended=t.bind(this),super.on(e,t)):"question"===e?(this.addQuestionHandler(e,t),super.on(e,t)):super.on(e,t)}shouldConnectToUser(e,t){return super.shouldConnectToUser(e,t)}changeName(e){super.changeName(e)}onNameChange(e,t){super.onNameChange(e,t),this.emit("namechange",e,t)}onConnectedToMQTT(){console.log("Connected to MQTT"),this.emit("mqttconnected")}onConnectedToUser(e){console.log("Connected to user ",e),this.emit("connectedtopeer",e)}onDisconnectedFromUser(e){console.log("Disconnected from user ",e),this.emit("disconnectedfrompeer",e)}onRTCDM(e,t){this.emit("dm",e,t)}onRTCChat(e,t){this.emit("chat",e,t)}addQuestionHandler(e,t){super.addQuestionHandler(e,t)}oncallconnected(e,{localStream:t,remoteStream:n}){this.emit("callconnected",e,{localStream:t,remoteStream:n})}pingEveryone(){let e=Date.now();return super.pingEveryone().then(()=>{console.log("Pinged everyone in "+(Date.now()-e)+"ms")})}ping(e){let t=Date.now();return super.ping(e).then(()=>{console.log("Pinged "+e+" in "+(Date.now()-t)+"ms")})}receivedPing(e){this.emit("ping",e)}get nextDMPromise(){return this.nextDM()}get nextChatPromise(){return this.nextChat()}get nextQuestionPromise(){return this.nextQuestion()}get nextAnswerPromise(){return this.nextAnswer()}get nextPingPromise(){return this.nextPing()}get nextPongPromise(){return this.nextPong()}get nextUserDisconnectionPromise(){return this.nextUserDisconnection()}get connectedUsers(){return this.connectionsToUsers()}disconnectFromUser(e){return super.disconnectFromUser(e),this.nextUserDisconnection(e)}getPeer(e){return new p(this,e)}get peers(){return Object.fromEntries(Object.entries(this.connectedUsers).map(e=>[e,new p(this,e)]))}get peerList(){return Object.values(this.peers)}send(e,t="chat",n){return super.sendOverRTC(t,e,n)}}class p{constructor(e,t){this.mqttClient=e,this.target=t}dm(e){return this.mqttClient.sendRTCDM(e,this.target)}chat(e){return this.mqttClient.sendRTCChat(e)}ask(e){return this.mqttClient.sendRTCQuestion(e,this.target)}ping(){return this.mqttClient.ping(this.target)}}class b{algorithm={name:"RSA-PSS",modulusLength:2048,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}};extractable=!0;keyUsages=["sign","verify"];constructor(e,t=!0,{storage:n=null,crypto:s=null}={}){if(this._name=null,this.name=e,this.storage=n||("undefined"!=typeof localStorage?{getItem:e=>localStorage.getItem(e),setItem:(e,t)=>localStorage.setItem(e,t),removeItem:e=>localStorage.removeItem(e)}:null),this.crypto=s||("undefined"!=typeof window&&window.crypto?window.crypto:null),!this.crypto||!this.crypto.subtle)throw new Error("Web Crypto API not available. Please provide a crypto instance via constructor.");this._loadKeys=this._loadKeys.bind(this),this.load=this.load.bind(this),this.generate=this.generate.bind(this),this._dumpKey=this._dumpKey.bind(this),this._loadPrivateKey=this._loadPrivateKey.bind(this),this._loadPublicKey=this._loadPublicKey.bind(this),this.sign=this.sign.bind(this),this.getChallengeString=this.getChallengeString.bind(this),this.verify=this.verify.bind(this),this.savePublicKey=this.savePublicKey.bind(this),this.savePublicKeyString=this.savePublicKeyString.bind(this),this.getPublicKey=this.getPublicKey.bind(this),this.clearOwnKeys=this.clearOwnKeys.bind(this),this.clearKnownHosts=this.clearKnownHosts.bind(this),this.getPeerNames=this.getPeerNames.bind(this),this.reset=this.reset.bind(this),this.loadedPromise=this.load(t)}load(e=!0){return this.loading=!0,this.loaded=!1,this.loadedPromise=this._loadKeys(e).then(e=>{if(this.storage){this._knownHostsStrings=JSON.parse(this.storage.getItem("knownHostsStrings")||"{}");for(let[e,t]of Object.entries(this._knownHostsStrings))e.startsWith("anon")&&delete this._knownHostsStrings[e];this._knownHostsKeys={}}else this._knownHostsStrings={},this._knownHostsKeys={};return this._privateKey=e.privateKey,this._publicKey=e.publicKey,this._privateKeyString=e.privateKeyString,this.publicKeyString=e.publicKeyString,this.storage&&(this.storage.setItem("privateKeyString",this._privateKeyString),this.storage.setItem("publicKeyString",this.publicKeyString)),this.loaded=!0,this.loading=!1,this.publicKeyString}),this.loadedPromise}_loadKeys(e=!0){if(!this.storage){if(!e)throw new Error("No storage available and generate is false");return this.generate()}let t=this.storage.getItem("privateKeyString"),n=this.storage.getItem("publicKeyString");if("force"!==e&&n&&t)return this._loadPrivateKey(t).then(e=>this._loadPublicKey(n).then(s=>({privateKey:e,publicKey:s,privateKeyString:t,publicKeyString:n})));if(!e)throw new Error("No keys found and generate is false");return this.generate()}generate(){return this.crypto.subtle.generateKey(this.algorithm,this.extractable,this.keyUsages).then(e=>this._dumpKey(e.privateKey).then(t=>(e.privateKeyString=t,this._dumpKey(e.publicKey).then(t=>(e.publicKeyString=t,e)))))}_dumpKey(e){return this.crypto.subtle.exportKey("jwk",e).then(JSON.stringify)}_loadPrivateKey(e){return this.crypto.subtle.importKey("jwk",JSON.parse(e),this.algorithm,this.extractable,["sign"])}_loadPublicKey(e){return this.crypto.subtle.importKey("jwk",JSON.parse(e),this.algorithm,this.extractable,["verify"])}getChallengeString(){return Array.from(this.crypto.getRandomValues(new Uint8Array(32))).map(e=>String.fromCharCode(e)).join("")}sign(e){return this.loading&&!this._loaded?this.loadedPromise.then(()=>this.sign(e)):this.crypto.subtle.sign({name:"RSA-PSS",saltLength:32},this._privateKey,new Uint8Array(e.split("").map(e=>e.charCodeAt(0))).buffer).then(e=>String.fromCharCode.apply(null,new Uint8Array(e)))}verify(e,t,n){return this._loadPublicKey(e).then(e=>this.crypto.subtle.verify({name:"RSA-PSS",saltLength:32},e,new Uint8Array(t.split("").map(e=>e.charCodeAt(0))).buffer,new Uint8Array(n.split("").map(e=>e.charCodeAt(0))).buffer))}getPeerNames(e){let t=[];if(!this._knownHostsStrings)return t;for(let[n,s]of Object.entries(this._knownHostsStrings))s===e&&t.push(n);return t}savePublicKey(e,t){return e=e.split("|")[0].split("(")[0].trim(),t instanceof CryptoKey?this._dumpKey(t).then(n=>(this.savePublicKey(e,n),this._knownHostsKeys[e]=t,!0)):this.savePublicKeyString(e,t)}savePublicKeyString(e,t){e=e.split("|")[0].split("(")[0].trim();let n=this.getPeerNames(t);if(n.length>0){if(n.includes(e))return this._knownHostsStrings[e]=t,this.storage&&this.storage.setItem("knownHostsStrings",JSON.stringify(this._knownHostsStrings)),!0;throw console.error("Public key already registered for another peer",n),new Error("Public key already registered for another peer")}return this._knownHostsStrings[e]=t,this.storage&&this.storage.setItem("knownHostsStrings",JSON.stringify(this._knownHostsStrings)),!0}getPublicKey(e){e=e.split("|")[0].split("(")[0].trim();let t=this._knownHostsKeys?.[e];if(t)return Promise.resolve(t);let n=this._knownHostsStrings?.[e];return n?this._loadPublicKey(n).then(t=>(this._knownHostsKeys||(this._knownHostsKeys={}),this._knownHostsKeys[e]=t,t)):Promise.resolve(null)}getPublicKeyString(e){return e=e.split("|")[0].split("(")[0].trim(),this._knownHostsStrings?.[e]||null}removePublicKey(e){e=e.split("|")[0].split("(")[0].trim(),this._knownHostsStrings&&delete this._knownHostsStrings[e],this._knownHostsKeys&&delete this._knownHostsKeys[e],this.storage&&this.storage.setItem("knownHostsStrings",JSON.stringify(this._knownHostsStrings||{}))}get knownHosts(){return this._knownHostsStrings?Object.entries(this._knownHostsStrings).map(([e,t])=>e+"|"+t):[]}clearOwnKeys(){this.storage&&(this.storage.removeItem("privateKeyString"),this.storage.removeItem("publicKeyString")),this._privateKey=null,this._publicKey=null,this._privateKeyString=null,this.publicKeyString=null}clearKnownHosts(){this.storage&&this.storage.removeItem("knownHostsStrings"),this._knownHostsKeys={},this._knownHostsStrings={}}reset(){this.clearOwnKeys(),this.clearKnownHosts()}get name(){return this._name}set name(e){if(e.includes("|"))throw new Error("Name cannot contain |");this._name=e}get identity(){if(!this.loaded)return null;return this.name.split("|")[0].split("(")[0].trim()+"|"+this.publicKeyString}register(e){let[t,n]=e.split("|");return this.savePublicKeyString(t,n)}}let y={reject:0,promptandtrust:1,connectandprompt:2,connectandtrust:3},f={trusted:0,nonsuspicious:1,slightlyodd:2,odd:3,veryodd:4};return e.BaseMQTTRTCClient=d,e.ConfigPresets=o,e.DeferredPromise=c,e.EventEmitter=a,e.Keys=b,e.LocalStorageAdapter=r,e.MQTTLoader=h,e.MQTTRTCClient=g,e.MemoryAdapter=class extends i{constructor(){super(),this.data={}}getItem(e){return this.data[e]||null}setItem(e,t){this.data[e]=String(t)}removeItem(e){delete this.data[e]}clear(){this.data={}}key(e){return Object.keys(this.data)[e]||null}get length(){return Object.keys(this.data).length}},e.Peer=p,e.PromisefulMQTTRTCClient=m,e.RTCConfig=s,e.RTCConnection=u,e.SignedMQTTRTCClient=class extends g{constructor(e){const t=(e=e||{})instanceof s?e:new s(e),n=t.getConfig(),o=!1!==e.generate,i=!1!==n.load,r=e.trustMode||n.trustMode||"strict",a=t.name,c=n.connection?.autoAcceptConnections??!1;super({...e,load:!1});const l=a||(this.name?this.name.split("(")[0]:"User"),h=this.storage||("undefined"!=typeof localStorage?{getItem:e=>localStorage.getItem(e),setItem:(e,t)=>localStorage.setItem(e,t),removeItem:e=>localStorage.removeItem(e)}:null),d=n.crypto||("undefined"!=typeof window&&window.crypto?window.crypto:null);if(this.keys=new b(l,o,{storage:h,crypto:d}),this.validatedPeers=[],void 0===r&&(r="strict"),this.trustConfigs[r]?this.trustConfig=this.trustConfigs[r]:this.trustConfig=r,!this.trustConfig||Object.keys(this.userCategories).map(e=>this.trustConfig[e]).some(e=>void 0===e))throw new Error("Invalid trust mode");this.completeUserInfo={},this.shouldConnectToUser=this.shouldConnectToUser.bind(this),this.checkTrust=this.checkTrust.bind(this),this._getFullUserInfo=this._getFullUserInfo.bind(this),this.trust=this.trust.bind(this),this.register=this.register.bind(this),this.challenge=this.challenge.bind(this),this.untrust=this.untrust.bind(this),this.autoAcceptConnections=c,this.addQuestionHandler("identify",this._returnPublicKey.bind(this)),this.addQuestionHandler("challenge",this._sign.bind(this)),this.on("connectedtopeer",e=>{setTimeout(()=>{this.trustOrChallenge.bind(this)(e)},1e3)}),i&&this.keys.loadedPromise.then(()=>{this.userInfo.publicKeyString=this.keys.publicKeyString,this.load()})}verifyUser(e,t,n){return console.log("Verifying user",e,t,n,this.validatedPeers),!(!["question","answer"].includes(e)||!["identify","challenge"].includes(t.question.topic))||this.validatedPeers.includes(n)}_getFullUserInfo(e,t){let n=e.split("|")[0].split("(")[0].trim();if(n.startsWith("anon"))return{peerName:e,bareName:n,userInfo:t,providedPubKey:!1,knownPubKey:!1,knownName:!1,otherNamesForPubKey:[],otherPubKeyForName:null,completedChallenge:!1,explanation:"anonymous",suspiciousness:f.nonsuspicious,category:"nevermet",hint:"anon"};let s=!!t.publicKeyString,o=s?this.keys.getPeerNames(t.publicKeyString):[],i=this.keys.getPublicKeyString(n),r={peerName:e,bareName:n,userInfo:t,providedPubKey:s,knownPubKey:o.length>0,knownName:o.includes(n),otherNamesForPubKey:o.filter(e=>e!==n),otherPubKeyForName:i&&i!==t.publicKeyString?i:null,completedChallenge:!1},a=this.categorizeUser(r);r.explanation=a.explanation,r.suspiciousness=a.suspiciousness,r.category=a.category;let c="";return"theoneandonly"===r.category?c="":["knownwithknownaliases","possiblenamechange","possiblesharedpubkey"].includes(r.category)?c=` who is known as ${r.otherNamesForPubKey.join(", ")}`:"nameswapcollision"===r.category?c=`it appears ${r.otherNamesForPubKey[0]} (who you know) is using ${e}'s public key to impersonate them'`:"pretender"===r.category?c=` who is pretending to be ${r.otherNamesForPubKey[0]}`:"nevermet"===r.category&&(c=" who you have not met"),c=c?` (${c})`:"",r.hint=c,r}shouldConnectToUser(e,t){console.log("Checking if we should connect to user",e,t);let n=this._getFullUserInfo(e,t);console.log("info",n);let s=this.checkTrust(n);return n.trustLevel=s,n.trustLevelString=Object.keys(this.trustLevels).find(e=>this.trustLevels[e]===s),this.completeUserInfo[e]&&this.isConnectedToUser(e)?(console.warn("Rejecting connection to "+e+" because we are already connected to someone with that name"),Promise.resolve(!1)):(this.completeUserInfo[e]=n,s===y.reject?(console.error("Rejecting connection to "+e),Promise.resolve(!1)):[y.doubleprompt,y.promptandtrust].includes(s)?this.connectionrequest(e,n).then(t=>(t?console.log("Decided to connect to "+e):console.log("Decided not to connect to "+e),t),e=>(console.log("Error in connection request",e),!1)):(console.log("will connect to "+e),Promise.resolve(!0)))}trustLevels=y;suspicionLevels=f;userCategories={theoneandonly:{knownPubKey:!0,knownName:!0,otherNamesForPubKey:!1,otherPubKeyForName:!1,explanation:"you know this person by the public key provided and don't now anyone else by this name or public key",suspiciousness:f.trusted,category:"theoneandonly"},knownwithknownaliases:{knownPubKey:!0,knownName:!0,otherNamesForPubKey:!0,otherPubKeyForName:!1,explanation:"you know this person by the public key provided, but you also know them by other names",suspiciousness:f.slightlyodd,category:"knownwithknownaliases"},possiblenamechange:{knownPubKey:!0,knownName:!1,otherNamesForPubKey:1,otherPubKeyForName:!1,explanation:"you recognize the public key but know it by a different name",suspiciousness:f.slightlyodd,category:"possiblenamechange"},possiblesharedpubkey:{knownPubKey:!0,knownName:!1,otherNamesForPubKey:!0,otherPubKeyForName:!1,explanation:"you recognize the public key but know it by more than one other name",suspiciousness:f.slightlyodd,category:"possiblesharedpubkey"},nameswapcollision:{knownPubKey:!0,knownName:!1,otherNamesForPubKey:!0,otherPubKeyForName:!0,explanation:"someone you know tried to change their name to the name of someone else you know",suspiciousness:f.odd,category:"nameswapcollision"},pretender:{knownPubKey:!1,knownName:!1,otherNamesForPubKey:!1,otherPubKeyForName:!0,explanation:"someone you don't know is using the name of someone you do know",suspiciousness:f.veryodd,category:"pretender"},nevermet:{knownPubKey:!1,knownName:!1,otherNamesForPubKey:!1,otherPubKeyForName:!1,explanation:"you don't know anyone with this pub key or name, you probably just haven't met yet",suspiciousness:f.notsuspicious,category:"nevermet"}};trustConfigs={alwaysprompt:{theoneandonly:y.promptandtrust,knownwithknownaliases:y.promptandtrust,possiblenamechange:y.promptandtrust,possiblesharedpubkey:y.promptandtrust,nameswapcollision:y.promptandtrust,pretender:y.promptandtrust,nevermet:y.promptandtrust},strict:{theoneandonly:y.connectandtrust,knownwithknownaliases:y.promptandtrust,possiblenamechange:y.promptandtrust,possiblesharedpubkey:y.promptandtrust,nameswapcollision:y.promptandtrust,pretender:y.promptandtrust,nevermet:y.promptandtrust},strictandquiet:{theoneandonly:y.connectandtrust,knownwithknownaliases:y.reject,possiblenamechange:y.reject,possiblesharedpubkey:y.reject,nameswapcollision:y.reject,pretender:y.reject,nevermet:y.promptandtrust},moderate:{theoneandonly:y.connectandtrust,knownwithknownaliases:y.connectandtrust,possiblenamechange:y.connectandtrust,possiblesharedpubkey:y.connectandtrust,nameswapcollision:y.promptandtrust,pretender:y.promptandtrust,nevermet:y.promptandtrust},moderateandquiet:{theoneandonly:y.connectandtrust,knownwithknownaliases:y.connectandtrust,possiblenamechange:y.connectandtrust,possiblesharedpubkey:y.connectandtrust,nameswapcollision:y.reject,pretender:y.reject,nevermet:y.promptandtrust},lax:{theoneandonly:y.connectandtrust,knownwithknownaliases:y.connectandtrust,possiblenamechange:y.connectandtrust,possiblesharedpubkey:y.connectandtrust,nameswapcollision:y.promptandtrust,pretender:y.promptandtrust,nevermet:y.connectandtrust},unsafe:{theoneandonly:y.connectandtrust,knownwithknownaliases:y.connectandtrust,possiblenamechange:y.connectandtrust,possiblesharedpubkey:y.connectandtrust,nameswapcollision:y.connectandtrust,pretender:y.connectandtrust,nevermet:y.connectandtrust},rejectall:{theoneandonly:y.reject,knownwithknownaliases:y.reject,possiblenamechange:y.reject,possiblesharedpubkey:y.reject,nameswapcollision:y.reject,pretender:y.reject,nevermet:y.reject}};categorizeUser(e){if(e.knownPubKey){if(e.knownName){if(e.otherPubKeyForName)throw new Error("knownName should mean that this name matches the pubkey so therefore otherPubKeyForName should be null");return 0===e.otherNamesForPubKey.length?this.userCategories.theoneandonly:this.userCategories.knownwithknownaliases}if(0===e.otherNamesForPubKey.length)throw new Error("knownPubKey should mean that this pubkey matches at least one name so if knownName is false then there should be at least one other name for this pubkey");return 1===e.otherNamesForPubKey.length?e.otherPubKeyForName?this.userCategories.nameswapcollision:this.userCategories.possiblenamechange:e.otherPubKeyForName?this.userCategories.nameswapcollision:this.userCategories.possiblesharedpubkey}return e.otherPubKeyForName?this.userCategories.pretender:this.userCategories.nevermet}checkTrust({peerName:e,bareName:t,userInfo:n,providedPubKey:s,peerNames:o,knownPubKey:i,knownName:r,otherNamesForPubKey:a,otherPubKeyForName:c,completedChallenge:l,explanation:h,suspiciousness:d,category:u}){return console.log("Checking trust for "+e,u,this.trustConfig),this.trustConfig[u]}connectionrequest(e,t){if(this.autoAcceptConnections)return console.log("Auto-accepting connection request from",e),Promise.resolve(!0);let n=confirm("Do you want to connect to "+e+"?");return Promise.resolve(n)}trustOrChallenge(e){this.keys.getPublicKey(e).then(t=>{if(t)this.challenge(e);else{console.log("No public key found for "+e);let t=this.completeUserInfo[e];if(!t){t=this._getFullUserInfo(e,{});const n=this.checkTrust(t);t.trustLevel=n,t.trustLevelString=Object.keys(this.trustLevels).find(e=>this.trustLevels[e]===n),this.completeUserInfo[e]=t}const n=t.trustLevel;if([this.trustLevels.reject].includes(n))return console.error("Rejecting connection to "+e),void this.untrust(e);if([this.trustLevels.connectandprompt].includes(n))return void this.connectionrequest(e,t).then(t=>{t?this.trust(e):this.untrust(e)});[this.trustLevels.promptandtrust,this.trustLevels.connectandtrust].includes(n)&&this.trust(e)}})}_returnPublicKey(e,t){return console.log("Challenge received from "+t),this.keys.sign(e).then(e=>{let n={publicKeyString:this.keys.publicKeyString,signature:e};return console.log("Returning public key to "+t,n),n})}reset(){this.keys.reset(),this.validatedPeers=[]}trust(e){let t=this.keys.getPublicKeyString(e),n=this.keys.getChallengeString();return this.sendRTCQuestion("identify",n,e).then(({publicKeyString:s,signature:o})=>{if(t&&t!==s)throw console.error("Public key changed for "+e,t,s),new Error("Public key changed for "+e);return this.keys.verify(s,o,n).then(t=>{if(t){console.log("Signature valid for "+e+", trusting and saving public key");const t=this.keys.getPeerNames(s);return t.length>0&&!t.includes(e)&&(console.log("Public key already registered to",t,"updating to",e),t.forEach(e=>{delete this.keys._knownHostsStrings[e]}),this.keys.storage&&this.keys.storage.setItem("knownHostsStrings",JSON.stringify(this.keys._knownHostsStrings))),this.keys.savePublicKeyString(e,s),this.onValidatedPeer(e,!0),this.validatedPeers.push(e),!0}return console.error("Signature invalid for "+e),this.untrust(e),this.onValidationFailed(e),!1})})}challenge(e){let t=this.keys.getPublicKeyString(e),n=this.keys.getChallengeString();return this.sendRTCQuestion("challenge",n,e).then(s=>this.keys.verify(t,s,n).then(t=>(console.log("Signature valid for "+e,t),this.validatedPeers.push(e),console.log("Validated peers",this.validatedPeers),this.onValidatedPeer(e),t),t=>{throw console.error("Error verifying signature of "+e,t),this.untrust(e),this.onValidationFailed(e),t}))}on(e,t){return"connectionrequest"===e?(this.connectionrequest=t,super.on(e,t)):super.on(e,t)}onValidatedPeer(e,t=!1){t&&console.log("Trusting peer "+e+" is who they say they are."),console.log("Peer "+e+" validated"),this.emit("validation",e,t)}onValidationFailed(e,t){console.error("Peer "+e+" validation failed"+(t?": "+t:"")),this.emit("validationfailure",e,t)}untrust(e){this.keys.removePublicKey(e),console.error("Untrusting peer "+e,this.validatedPeers),this.validatedPeers.includes(e)&&(this.validatedPeers=this.validatedPeers.filter(t=>t!==e)),console.error("Disconnecting from untrusted peer "+e,this.validatedPeers),this.disconnectFromUser(e)}_sign(e,t){return this.keys.sign(e)}register(e){return this.keys.register(e)}},e.StorageAdapter=i,e.TabManager=l,e.deepMerge=n,e.isObject=t,e}({});
